<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Umit Akkose" />
  <meta name="author" content="Veysel Ogulcan Kaya" />
  <meta name="author" content="Laura Lindsey-Boltz" />
  <meta name="author" content="Zeynep Karagoz" />
  <meta name="author" content="Adam D. Brown" />
  <meta name="author" content="Peter A. Larsen" />
  <meta name="author" content="Anne D. Yoder" />
  <meta name="author" content="Aziz Sancar" />
  <meta name="author" content="Ogun Adebali" />
  <meta name="dcterms.date" content="2020-04-03" />
  <meta name="keywords" content="DNA repair, Nucleotide excision repair, UV damage, Gray Mouse Lemur, Fibroblasts" />
  <title>Comparative analyses of two primate species diverged by more than 60 million years show different rates but similar distribution of genome-wide UV repair events.</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <!--
  Manubot generated metadata rendered from header-includes-template.html.
  Suggest improvements at https://github.com/manubot/manubot/blob/master/manubot/process/header-includes-template.html
  -->
  <meta name="dc.format" content="text/html" />
  <meta name="dc.title" content="Comparative analyses of two primate species diverged by more than 60 million years show different rates but similar distribution of genome-wide UV repair events." />
  <meta name="citation_title" content="Comparative analyses of two primate species diverged by more than 60 million years show different rates but similar distribution of genome-wide UV repair events." />
  <meta property="og:title" content="Comparative analyses of two primate species diverged by more than 60 million years show different rates but similar distribution of genome-wide UV repair events." />
  <meta property="twitter:title" content="Comparative analyses of two primate species diverged by more than 60 million years show different rates but similar distribution of genome-wide UV repair events." />
  <meta name="dc.date" content="2020-04-03" />
  <meta name="citation_publication_date" content="2020-04-03" />
  <meta name="dc.language" content="en-US" />
  <meta name="citation_language" content="en-US" />
  <meta name="dc.relation.ispartof" content="Manubot" />
  <meta name="dc.publisher" content="Manubot" />
  <meta name="citation_journal_title" content="Manubot" />
  <meta name="citation_technical_report_institution" content="Manubot" />
  <meta name="citation_author" content="Umit Akkose" />
  <meta name="citation_author_institution" content="Molecular Biology, Genetics &amp; Bioengineering Program, Faculty of Engineering and Natural Sciences, Sabanci University, Istanbul, 34956, Turkey" />
  <meta name="citation_author_orcid" content="0000-0002-9731-3702" />
  <meta name="citation_author" content="Veysel Ogulcan Kaya" />
  <meta name="citation_author_institution" content="Molecular Biology, Genetics &amp; Bioengineering Program, Faculty of Engineering and Natural Sciences, Sabanci University, Istanbul, 34956, Turkey" />
  <meta name="citation_author_orcid" content="0000-0002-3447-0735" />
  <meta name="citation_author" content="Laura Lindsey-Boltz" />
  <meta name="citation_author_institution" content="Department of Biochemistry and Biophysics, School of Medicine, University of North Carolina at Chapel Hill, Chapel Hill, North Carolina, 27599, USA" />
  <meta name="citation_author_orcid" content="0000-0001-6493-8194" />
  <meta name="citation_author" content="Zeynep Karagoz" />
  <meta name="citation_author_institution" content="Molecular Biology, Genetics &amp; Bioengineering Program, Faculty of Engineering and Natural Sciences, Sabanci University, Istanbul, 34956, Turkey" />
  <meta name="citation_author_orcid" content="0000-0002-7627-9218" />
  <meta name="citation_author" content="Adam D. Brown" />
  <meta name="citation_author_institution" content="Department of Pharmacology and Cancer Biology, Duke University, Durham, North Carolina, 27708, USA" />
  <meta name="citation_author_orcid" content="0000-0002-9122-4960" />
  <meta name="citation_author" content="Peter A. Larsen" />
  <meta name="citation_author_institution" content="Department of Biology, Duke University, Durham, North Carolina, 27708, USA" />
  <meta name="citation_author_orcid" content="0000-0002-3634-3625" />
  <meta name="citation_author" content="Anne D. Yoder" />
  <meta name="citation_author_institution" content="Department of Biology, Duke University, Durham, North Carolina, 27708, USA" />
  <meta name="citation_author_orcid" content="0000-0002-1781-9552" />
  <meta name="citation_author" content="Aziz Sancar" />
  <meta name="citation_author_institution" content="Department of Biochemistry and Biophysics, School of Medicine, University of North Carolina at Chapel Hill, Chapel Hill, North Carolina, 27599, USA" />
  <meta name="citation_author_orcid" content="0000-0001-6469-4900" />
  <meta name="citation_author" content="Ogun Adebali" />
  <meta name="citation_author_institution" content="Molecular Biology, Genetics &amp; Bioengineering Program, Faculty of Engineering and Natural Sciences, Sabanci University, Istanbul, 34956, Turkey" />
  <meta name="citation_author_orcid" content="0000-0001-9213-4070" />
  <meta name="twitter:creator" content="@compGenomics" />
  <meta property="og:type" content="article" />
  <meta property="twitter:card" content="summary_large_image" />
  <link rel="icon" type="image/png" sizes="192x192" href="https://manubot.org/favicon-192x192.png" /> <link rel="mask-icon" href="https://manubot.org/safari-pinned-tab.svg" color="#ad1457" />
  <meta name="theme-color" content="#ad1457" />
  <!-- end Manubot generated metadata -->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Comparative analyses of two primate species diverged by more than 60 million years show different rates but similar distribution of genome-wide UV repair events.</h1>
</header>
<p><a href="https://orcid.org/0000-0002-9731-3702"><img src="images/orcid.svg" width="11" height="11" alt="ORCID icon" /></a> Umit Akkose<sup>1,#</sup>, <a href="https://orcid.org/0000-0002-3447-0735"><img src="images/orcid.svg" width="11" height="11" alt="ORCID icon" /></a> Veysel Ogulcan Kaya<sup>1,#</sup>, <a href="https://orcid.org/0000-0001-6493-8194"><img src="images/orcid.svg" width="11" height="11" alt="ORCID icon" /></a> Laura Lindsey-Boltz<sup>2,#</sup>, <a href="https://orcid.org/0000-0002-7627-9218"><img src="images/orcid.svg" width="11" height="11" alt="ORCID icon" /></a> Zeynep Karagoz<sup>1</sup>, <a href="https://orcid.org/0000-0002-9122-4960"><img src="images/orcid.svg" width="11" height="11" alt="ORCID icon" /></a> Adam D. Brown<sup>3</sup>, <a href="https://orcid.org/0000-0002-3634-3625"><img src="images/orcid.svg" width="11" height="11" alt="ORCID icon" /></a> Peter A. Larsen<sup>4,†</sup>, <a href="https://orcid.org/0000-0002-1781-9552"><img src="images/orcid.svg" width="11" height="11" alt="ORCID icon" /></a> Anne D. Yoder<sup>4</sup>, <a href="https://orcid.org/0000-0001-6469-4900"><img src="images/orcid.svg" width="11" height="11" alt="ORCID icon" /></a> Aziz Sancar<sup>2</sup>, <a href="https://orcid.org/0000-0001-9213-4070"><img src="images/orcid.svg" width="11" height="11" alt="ORCID icon" /></a> Ogun Adebali<sup>1,*</sup></p>
<p><small></p>
<ol type="1">
<li>Molecular Biology, Genetics &amp; Bioengineering Program, Faculty of Engineering and Natural Sciences, Sabanci University, Istanbul, 34956, Turkey</li>
<li>Department of Biochemistry and Biophysics, School of Medicine, University of North Carolina at Chapel Hill, Chapel Hill, North Carolina, 27599, USA</li>
<li>Department of Pharmacology and Cancer Biology, Duke University, Durham, North Carolina, 27708, USA</li>
<li>Department of Biology, Duke University, Durham, North Carolina, 27708, USA</li>
</ol>
<p><sup>†</sup> Current Address: Department of Veterinary and Biomedical Sciences, University of Minnesota, St. Paul, Minnesota, 55112, USA <br> <br> <sup>#</sup> These authors contributed equally<br> <sup>*</sup> To whom correspondence should be addressed: oadebali@sabanciuniv.edu </small></p>
<p><small> <strong>Running title</strong>: Nucleotide excision repair profiles in primates </small></p>
<p><small> <strong>Keywords:</strong> Nucleotide excision repair, UV damage, XR-seq, Mouse Lemur, (6-4)PP, CPD, Primate </small></p>
<h2 class="page_break_before" id="abstract" class="page_break_before">Abstract</h2>
<!-- 250 words -->
<p>Nucleotide excision repair is the primary DNA repair mechanism that removes bulky DNA adducts such as UV-induced pyrimidine dimers. Correspondingly, genome-wide mapping of nucleotide excision repair with eXcision Repair sequencing (XR-seq), provides comprehensive profiling of DNA damage repair. A number of XR-seq experiments at a variety of conditions for different damage types revealed heterogenous repair in the human genome. Although human repair profiles were extensively studied, how repair maps vary between primates is yet to be investigated. Here, we characterized the genome-wide UV-induced damage repair in gray mouse lemur,<em>Microcebus murinus</em>, in comparison to human. Mouse lemurs are strictly nocturnal, are the world’s smallest living primates, and last shared a common ancestor with humans at least 60 million years ago. We derived fibroblast cell lines from mouse lemur, exposed them to UV irradiation, and the repair events were captured genome-wide by the XR-seq protocol. Mouse lemur repair profiles were analyzed in comparison to the equivalent human fibroblast datasets. We found that overall UV sensitivity, repair efficiency, and transcription-coupled repair levels differ between two primates. Despite this, comparative analysis of human and mouse lemur fibroblasts revealed that genome-wide repair profiles of the homologous regions between the primates are highly correlated. This correlation is stronger for the highly expressed genes. With the inclusion of an additional XR-seq sample derived from another human cell line in the analysis, we found that fibroblasts between two primates repair UV-induced DNA lesions in a more similar pattern than two distinct human cell lines do. Our results suggest that mouse lemurs and humans, and possibly primates in general, share a homologous repair mechanism as well as genomic variance distribution, albeit with their variable repair efficiency. This result also emphasizes the deep homologies of individual tissue types across the eukaryotic phylogeny.</p>
<h2 id="introduction">Introduction</h2>
<p>Nucleotide excision repair is an essential mechanism to remove bulky DNA adducts including UV-induced DNA lesions <span class="citation" data-cites="bYJTOmGw">(Hu et al. <a href="#ref-bYJTOmGw" role="doc-biblioref">2017</a><a href="#ref-bYJTOmGw" role="doc-biblioref">b</a>)</span>. As in other repair systems, excision repair starts with damage recognition. Two subpathways based upon damage recognition lead to two repair mechanisms: global repair (GR) and transcription-coupled repair (TCR). GR is active throughout the genome whereas TCR is only active on the transcribed strands as it is initiated by damage recognition through stalled RNA polymerase II (RNAPII). To date, many techniques have been developed to detect DNA damage and repair <span class="citation" data-cites="cZtF6zIe">(Li and Sancar <a href="#ref-cZtF6zIe" role="doc-biblioref">2020</a>)</span>. The approach of some methologies has been NGS-based, which allows answering genome-wide questions. To reveal genome-wide excision repair dynamics, heterogeneity and associations, eXcsion Repair sequencing (XR-seq) was developed. XR-seq technique directly measures the repair events by capturing the excised oligomer containing the lesion. It was found that TCR is more efficient particularly for slowly-repaired DNA lesions. For instance, among UV photoproducts 6-4 pyrimidine-pyrimidone ([6-4]PP) and cyclobutane pyrimidine dimer (CPD), CPD is more prone to TCR as it is less efficiently repaired by GR. Although DNA lesions might preferentially form at certain local sites in the genome, the overall heterogeneity of repair is majorly due to uneven repair efficiency throughout the genome <span class="citation" data-cites="10FU8PPzJ zxIvoFqn">(Hu et al. <a href="#ref-10FU8PPzJ" role="doc-biblioref">2017</a><a href="#ref-10FU8PPzJ" role="doc-biblioref">a</a>; Mao et al. <a href="#ref-zxIvoFqn" role="doc-biblioref">2018</a>)</span>. Genome-wide heterogenous repair distribution is mostly caused by transcription and chromatin structure <span class="citation" data-cites="OhKg9ZHE ZAV7FWhL 4WTs70ml hJRoVR8L">(Hu et al. <a href="#ref-OhKg9ZHE" role="doc-biblioref">2015</a>, <a href="#ref-ZAV7FWhL" role="doc-biblioref">2016</a>; Adar et al. <a href="#ref-4WTs70ml" role="doc-biblioref">2016</a>; Yimit et al. <a href="#ref-hJRoVR8L" role="doc-biblioref">2019</a>)</span>.</p>
<p>To date, genome-wide repair maps were generated for model organisms including <em>Escherichia coli</em> <span class="citation" data-cites="18edpunap 1190rUeCp">(Adebali et al. <a href="#ref-18edpunap" role="doc-biblioref">2017</a><a href="#ref-18edpunap" role="doc-biblioref">a</a>, <a href="#ref-1190rUeCp" role="doc-biblioref">2017</a><a href="#ref-1190rUeCp" role="doc-biblioref">b</a>)</span>, <em>Saccharomyces cerevisia</em> <span class="citation" data-cites="OSVE68co">(Li et al. <a href="#ref-OSVE68co" role="doc-biblioref">2018</a>)</span>, <em>Drosophila melanogaster</em> <span class="citation" data-cites="iyn6rN7q">(Deger et al. <a href="#ref-iyn6rN7q" role="doc-biblioref">2019</a>)</span>, <em>Arabidopsis thaliana</em> <span class="citation" data-cites="12APhIkm8">(Oztas et al. <a href="#ref-12APhIkm8" role="doc-biblioref">2018</a>)</span>, <em>Mus musculus</em> <span class="citation" data-cites="AXdS7vVN">(Yang et al. <a href="#ref-AXdS7vVN" role="doc-biblioref">2018</a>)</span>, and <em>Homo sapiens</em> <span class="citation" data-cites="OhKg9ZHE 10FU8PPzJ">(Hu et al. <a href="#ref-OhKg9ZHE" role="doc-biblioref">2015</a>, <a href="#ref-10FU8PPzJ" role="doc-biblioref">2017</a><a href="#ref-10FU8PPzJ" role="doc-biblioref">a</a>)</span>. TCR presence was verified for each of these organisms. For eukaryotic genomes, the consistent finding was the efficient repair in open chromatin regions. Heterochromatin regions were found to be repaired at later time points. Human repair profiles were extensively studied with respect to damage formation and chromatin states. Whether regions in human genome that are efficient with respect to repair are organism-specific is yet to be investigated.</p>
<p>To study whether repair patterns are unique to the organism of interest we aimed to compare human and a deeply diverged non-human primate. Gray mouse lemur (<em>Microcebus murinus</em>) stands out as a promising model organism candidate because of its small body size, short gestation time (2 months) and fast sexual maturation (6-8 months) <span class="citation" data-cites="CoujlGZF fKeXK6h7">(Blanco et al. <a href="#ref-CoujlGZF" role="doc-biblioref">2015</a>; Ezran et al. <a href="#ref-fKeXK6h7" role="doc-biblioref">2017</a>)</span>. A near chromosome level reference genome for the gray mouse lemur was recently sequenced and assembled <span class="citation" data-cites="1FNsl9JHL">(Larsen et al. <a href="#ref-1FNsl9JHL" role="doc-biblioref">2017</a>)</span>. With no surprise, it was shown that mouse lemur and human orthologs share ~91% identity. Although a robust genome assembly is available, we lack an in-depth understanding of this species’ genomic features such as epigenetic maps, transcriptomes and methylomes.</p>
<p>Given that mouse lemurs and humans last shared a common ancestor at the base of the primate clade <span class="citation" data-cites="1Gbi7LeDk">(Horvath and Willard <a href="#ref-1Gbi7LeDk" role="doc-biblioref">2007</a>)</span>, same cell types from human and mouse lemur should behave similary in response to DNA damage as a reflection of their deep homology. With this motivation, we carried out a comparative study between these two primates to understand similarities and differences between their repair profiles. We derived primary fibroblasts from mouse lemur and immortalized them. We performed survival assays in response to UV stress, immunoslot blot assays and in vivo excision assays for both cell lines. From mouse lemur fibroblasts, we obtained transcriptomes, exposed cells to UV and performed XR-seq. XR-seq captured the excised oligomers as repair products for two main UV-induced damage types: (6-4)PP and CPD. We compared lemur and human fibroblast XR-seq datasets with respect to their genomic repair distribution.</p>
<h2 id="results">Results</h2>
<h3 id="excised-oligomer-characteristics">Excised oligomer characteristics</h3>
<p>In vivo excision assay resulted in the excised oligomers containing UV-induced lesions (Fig <a href="#fig:fig1">1</a>A). Excised oligomers were captured for two distinct damage types with specific anti-damage antibodies. The oligomer length distribution varies from 16 to 30nt. Two intense bands were observed, which indicate primary and degraded excised oligomers. The gel images show that the primary excised oligomer lengths vary between 23-25nt. Through time course, gel images reflect a more intense secondary product band, suggesting higher levels of degraded excised oligomer with damage is observed at later time points. For normal human fibroblasts 1 (NHF1) and mouse lemur fibroblasts, this trend is similar.</p>
<p>Nucleotide excision repair in human, <em>S. cerevisiae</em> and <em>E. coli</em> was shown to yield primary excised oligomers predominantly in lengths of 27, 24 and 13 nucleotides, respectively <span class="citation" data-cites="1GUFhcYbP RCFCwjid OSVE68co uOxe2lBD 18edpunap">(Hu et al. <a href="#ref-1GUFhcYbP" role="doc-biblioref">2013</a>; Huang et al. <a href="#ref-RCFCwjid" role="doc-biblioref">1992</a>; Li et al. <a href="#ref-OSVE68co" role="doc-biblioref">2018</a>; Sancar and Rupp <a href="#ref-uOxe2lBD" role="doc-biblioref">1983</a>; Adebali et al. <a href="#ref-18edpunap" role="doc-biblioref">2017</a><a href="#ref-18edpunap" role="doc-biblioref">a</a>)</span>. Mouse lemur XR-seq resulted in excised oligomer distribution identical to humans (Fig <a href="#fig:fig1">1</a>B) thus indicating deep homology with human. This is supported by an identical pattern of oligomer length distribution between human and mouse lemur that is independent of the damage type. For both CPD and (6-4)PP, nucleotide excision repair machinery incised 26nt oligomer as the predominant product. A small variance in oligomer lengths between in vivo excision assay and XR-seq might be due to the immediate exonuclease activity on excised oligomer for in vivo excision assay. Because of the TFIIH coimmunoprecipitation in excision repair sequencing technique, XR-seq primary products are not yet degraded, possibly because of TFIIH protection of the excised oligomers.</p>
<h3 id="identical-cpd-and-6-4pp-nucleotide-frequency-between-human-and-lemur">Identical CPD and (6-4)PP nucleotide frequency between human and lemur</h3>
<p>Nucleotide frequencies of the excised oligomers between human and mouse lemur are identical for both CPD and (6-4)PP (Fig <a href="#fig:fig1">1</a>C). Pyrimidine enrichment was revealed at 19th, 20th and 21st nucleotides for CPD and (6-4)PP for both organisms, which is in agreement with the incision site at 6 to 8nt fixed distance to the 3’ end of the DNA lesion. The nucleotide contents for CPD and (6-4)PP are different, as they were previously reported and discussed <span class="citation" data-cites="OhKg9ZHE">(Hu et al. <a href="#ref-OhKg9ZHE" role="doc-biblioref">2015</a>)</span>.</p>
<div id="fig:fig1" class="fignos">
<figure>
<img src="images/fig-1.png" class="white" alt="" /><figcaption><span>Figure 1:</span> Characteristics of excised oligomers upon repair of UV-induced damages. <em>(A)</em> In vivo excision assay for (6-4)PP and CPD are shown. <em>(B)</em> XR-seq read length distribution of excised oligomers for CPD (top) and (6-4)PP (bottom). Human and mouse lemur are shown in blue and red, respectively. <em>(C)</em> Nucleotide frequency in the predominant oligomer (26nt) for each primate and damage type. Representative data from replicate 1.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="uv-repair-efficiency-of-mouse-lemur-in-comparison-with-human" class="page_break_before">UV repair efficiency of mouse lemur in comparison with human</h3>
<p>To identify the overal repair efficieny upon UV irradiation we performed a colony survival assay. We seeded 300 cells and grew them for 16 hours. Cells were exposed to UV-C at 1 Joule m<span class="math inline">\(^2\)</span>/sec for variable time intervals to reach indicated doses ranging from 2.5 to 10 J/m<span class="math inline">\(^2\)</span>. We counted cells for each dose and plotted a survival curve for lemur and human fibroblasts (Fig <a href="#fig:fig2">2</a>A). Based on the survival curves we infer that mouse lemur fibroblasts are more sensitive to UV relative to human cells. This suggests a differential repair rate between the two species which is possibly reflective of the diurnal versus nocturnal habits of humans and mouse lemurs, respectively.</p>
<p>We then performed immunoslot blot assays (Fig <a href="#fig:fig2">2</a>B). Cells were exposed to UV-C at 10J/m<span class="math inline">\(^2\)</span>. To separate UV-induced DNA lesions we used specific antibodies for CPD and (6-4)PP. We quantified the remaining damage signal for each damage type for both organisms. Both (6-4)PP and CPD repair appeared to be more efficient in human cells compared to mouse lemur. In 2 hours (6-4)PP repair was completed in humans whereas in lemurs, it took 4 hours to complete (6-4)PP repair. After 32 hours of irradiation 20% of CPDs were still unrepaired for human cells. Unrepaired CPD ratio was more than 40% for mouse lemur cells. Survival and immonoslot blot assays are in harmony and they suggest mouse lemur cells have relatively low repair rates in comparison with NHF1 cells.</p>
<div id="fig:fig2" class="fignos">
<figure>
<img src="images/fig-2.png" class="white" style="width:66.0%" alt="" /><figcaption><span>Figure 2:</span> UV sensitivity and repair rates in human and lemur fibroblasts. <em>(A)</em> Clonogenic survival assay (left) and the quantified results (right). <em>(B)</em> Immunoslot blot repair assays to examine the repair kinetics of UV-induced DNA lesions for both organisms and each damage type (left). Remaining damage levels at each time point were quantified and plotted (right). All experiments were repeated three times, and graphed data are presented as (mean+/-SD).</figcaption>
</figure>
</div>
<h3 id="prominent-transcription-coupled-repair-in-mouse-lemur">Prominent transcription-coupled repair in mouse lemur</h3>
<p>Nucleotide excision repair comprises two sub-pathways each of which distinctly acts on damage recognition. GR is the genome-wide mechanism that is active in any region in the genome, although its efficiency depends on the type of damage as well as chromatin factors. On the other hand, TCR depends on the RNAPII stalled at the lesion. Stalled RNAPII recruits transcription-coupled repair factor CSB to enhance repair. As TCR occurs only when RNAPII is stalled, it is solely active in the regions that are transcribed by this polymerase. Also, TCR is only seen in the transcribed strand of the genes. DNA lesions in non-transcribed strands are subject to global repair. A major rate-limiting step of nucleotide excision repair is damage recognition. Therefore, minor helix-distorting lesions such as CPDs are recognized more efficiently when they stall otherwise elongating RNAPII. Therefore, in those organisms having TCR, genes have asymmetrical repair between two strands; transcribed strand (TS) is repaired more efficiently compared to nontranscribed strand (NTS) <span class="citation" data-cites="29W7k2UV NkhwUBAb">(Hanawalt and Spivak <a href="#ref-29W7k2UV" role="doc-biblioref">2008</a>; Mellon and Hanawalt <a href="#ref-NkhwUBAb" role="doc-biblioref">1989</a>)</span>.</p>
<p>Global repair for (6-4)PP is much faster than for CPD <span class="citation" data-cites="LyGwcDX7 4WTs70ml">(Steurer et al. <a href="#ref-LyGwcDX7" role="doc-biblioref">2019</a>; Adar et al. <a href="#ref-4WTs70ml" role="doc-biblioref">2016</a>)</span>. TCR only removes a minor fraction of the (6-4)PPs, and thus strand asymmetry between TS and NTS (TS/NTS ratio) is much weaker for (6-4)PP compared to the strand asymmetry of CPD repair <span class="citation" data-cites="4WTs70ml">(Adar et al. <a href="#ref-4WTs70ml" role="doc-biblioref">2016</a>)</span>. CPDs, on the other hand, are harder to be recognized by global repair, and therefore it takes a longer time to remove CPDs from the genome. For this reason, at early time points (such as 1 hour after UV irradiation), we observe a strong TCR effect which is indicated by the asymmetrical repair between TS and NTS. Here, we compared the genic strand asymmetry between human and mouse lemur (Fig <a href="#fig:fig3">3</a>). We retrieved all annotated protein-coding genes from both genomes. We removed the genes that are closer to each other with less than 20kb in order to remove the signal that might have a “canceling-out” effect. We used 5277 and 3366 annotated genes for human and mouse lemur, respectively (see methods). We performed a meta-analysis where we aligned all transcription start and transcription end sites and calculated the RPKM (reads per kilobase per million mapped reads) values. Interestingly, mouse lemur fibroblasts exhibited stronger TCR profiles compared to human cell lines at 1 hour after CPD formation.</p>
<div id="fig:fig3" class="fignos">
<figure>
<img src="images/fig-3.png" class="white" alt="" /><figcaption><span>Figure 3:</span> Transcription-coupled repair in mouse lemur and human fibroblasts. Average profiles of CPD XR-seq (top) and (6-4)PP XR-seq (bottom) over 5277 and 3366 annotated genes are plotted for human (left) and mouse lemur (right), respectively. Transcription start sites (TSS) and transcription end sites (TES) were retrieved from GTF (Gene Transfer Format) files for the two genomes. Transcribed (red) and nontranscribed (blue) strand repair are shown in the downstream and upstream of TSS and TES, respectively. 10 kb upstream and downstream of TSS and TES were divided into 100 bp windows. XR-seq reads falling onto each bin were normalized to RPKM (reads per kilobase per million mapped reads). The XR-seq RPKM values were normalized by the shuffled RPKM values derived by mapped reads onto sites that are random genomic sites. Only replicate 1 is shown.</figcaption>
</figure>
</div>
<h3 id="conserved-repair-rates-between-homologous-regions-of-two-primates">Conserved repair rates between homologous regions of two primates</h3>
<p>In order to compare and contrast the genome-wide repair profiles between humans and mouse lemurs, we retrieved the homologous genomic regions between the organisms (Fig <a href="#fig:fig4">4</a>A). We aligned the two genomes and kept the regions that have at least 80% similarity. Due to the low coverage of the XR-seq samples we removed the aligned segments that are shorter than 400 bases to eliminate the randomn effect due to scarce repair events. Lineage-specific duplications or deletions result in paralogs that can be co-orthologs to one locus in the other genome. This situation is known as the “one-to-multiple” orthology relationship. As we cannot be sure which one of the multiple paralogs in one genome is the “true” ortholog of a region in the other one, we filtered out one-to-multiple kinds of homologous relationships and kept one-to-one homologs only.</p>
<p>1.0% and 1.3% of the genomes were taken into account with one-to-one homologs for human and mouse lemur, respectively. 4-5% and 2-3% of the XR-seq reads mapped to those regions for CPD and (6-4)PP, respectively. The reason why the mapping rate of CPD is higher than (6-4)PP could be due to its slower repair rate, as slowly repaired CPDs are more prone to the effects of chromatin. Because we applied stringent criteria to retrieve the homologous regions with at least 80% identity, they are likely to be more open compared to other regions in the genome. Therefore, CPD repair events are mapped onto those regions more than (6-4)PP reads did.</p>
<p>We investigated the correlation between the repair profiles of the two species. Because excised oligomers have a certain nucleotide bias due to the damage site, we normalized the true repair signal (XR-seq) by the simulated XR-seq reads. Simulated reads have the nucleotide content of the true XR-seq reads (Fig <a href="#fig:S1">S1</a>), however they are randomly retrieved from randomized regions of the homologous regions. With this approach we eliminated potential bias of the nucleotide content that creates a pseudo-correlation. Although there is a clear difference in the relative TCR rates between two species (Fig <a href="#fig:fig3">3</a>), homologous regions of two genomes exhibited a strong repair rate correlation; R values for (6-4)PP and CPD are 0.80 and 0.72 (p=0), respectively (Fig <a href="#fig:fig4">4</a>B). Not only repair, but also transcription levels between the two species are correlated (Fig <a href="#fig:fig4">4</a>C). The similar repair and transcription profiles between two cell lines are independent of their chromosomal locations. Chromosomal homologous region associations are dispersed as previously suggested <span class="citation" data-cites="1FNsl9JHL">(Larsen et al. <a href="#ref-1FNsl9JHL" role="doc-biblioref">2017</a>)</span>.</p>
<div id="fig:fig4" class="fignos">
<figure>
<img src="images/fig4.png" class="white" alt="" /><figcaption><span>Figure 4:</span> Comparative analysis methodology and correlated repair rates between human and mouse lemur. A) Approach to detect orthologous regions between human and mouse lemur (see methods for details). B) Scatter plots showing the normalized repair levels between two organisms. Relative repair was calculated by normalizing the repair signal by the simulated XR-seq reads to eliminate the sequence bias. C) Mapped orthologous regions with repair and transcription profiles mapped at left and right outer rings, respectively. Inner circle represents the human (left) and mouse lemur (right) chromosomes. Inner lines connecting orthologous regions are colored based human chromosome color scale. Repair and transcription values (outer rings) for genomic regions that have no evident ortholog (based on the criteria in A) are not shown.</figcaption>
</figure>
</div>
<h3 id="repair-profile-correlation-is-associated-with-gene-expression">Repair profile correlation is associated with gene expression</h3>
<p>To understand what factors are associate with the correlation of repair between these two highly-diverged species of primates, we examined the correlation strength and gene expression levels. We prepared RNA-seq data sets for mouse lemur fibroblasts and obtained RNA-seq datasets for human fibroblasts from a publicly available database (see methods). The strength of the correlation between the two repair profiles was found to be correlated with transcription levels (Fig <a href="#fig:fig5">5</a>). Highly expressed regions had better repair correlation between the two species (Figs <a href="#fig:S2">S2</a>;<a href="#fig:S3">S3</a>;<a href="#fig:S4">S4</a>;<a href="#fig:S5">S5</a>).</p>
<div id="fig:fig5" class="fignos">
<figure>
<img src="images/fig5.png" class="white" alt="" /><figcaption><span>Figure 5:</span> Repair rate consistency in correlation with gene expression. The transcription levels of the orthologous regions were divided into quartiles separately for human and lemur. Out of the quartiles 10 bootstrapped subsamples were retrieved, and for those regions repair correlation was analyzed. Correlation coefficient (R values) are represented on the y-axis; quartiles are on the x-axis.</figcaption>
</figure>
</div>
<h3 id="the-same-cell-type-from-two-primates-have-more-similar-repair-profiles-relative-to-two-different-cell-types-from-the-same-organism">The same cell type from two primates have more similar repair profiles relative to two different cell types from the same organism</h3>
<p>We cannot dismiss the possibility that the correlation of repair profiles between two primates could simply be due to the heterogenous mappability of the genomes. Such a correlation makes sense only when we measure the similarity of repair patterns relative to another dataset. For this reason, we used another human cell type, GM12878 - B-Lymphocytes to ask whether the repair profile of human fibroblasts is closer to lemur fibroblasts or to human lymphocytes. We performed XR-seq for CPD as it yields relatively high genome-wide heterogeneity compared to (6-4)PP. Although repair profiles between human GM12878 and NHF1 are also correlated (Fig <a href="#fig:fig6">6</a>A), this correlation is not as strong as the one between human and mouse lemur fibroblasts. Additionally, human and mouse lemur fibroblasts clustered together in the PCA plot (Fig <a href="#fig:fig6">6</a>B). Within fibroblasts, biological replicates were grouped together. More interestingly, (6-4)PP and CPD samples formed distinct groups each of which has human and mouse lemur samples clustered together. The two replicates of CPD XR-seq samples of human lymphocytes (GM12878) were clustered as an outgroup. This result suggests that human and mouse lemur fibroblasts have similar chromatin and expression patterns and therefore have similar repair profiles. On the other hand, even though derived from the same organism, completely different human cell lines have a considerable variation with respect to repair patterns. It is also interesting to note that although TCR profiles between two primates are quite different from each other, they share high similarity in repair profiles.</p>
<div id="fig:fig6" class="fignos">
<figure>
<img src="images/fig6.png" class="white" style="width:100.0%" alt="" /><figcaption><span>Figure 6:</span> Cell type-based consistency of repair profiles between two primates. A) Scatter plot or normalized repair levels between two human cell lines, GM18787 and NHF1, show correlation. B) Principle component analysis of 10 XR-seq samples.</figcaption>
</figure>
</div>
<h2 id="discussion">Discussion</h2>
<p>XR-seq methodology has become prominent in genome-wide profiling of nucleotide excision repair at single nucleotide resolution. This technique has been applied to a variety of model organisms from human to bacteria. Although genome-level understanding of human repair behavior is relatively well established in the recent years, the association of the repair behavior and genome-wide distribution in the comparison with closely related organisms was entirely lacking. With this study, we established the differences and similarities between mouse lemur and human. First, we observed repair efficiency differences between the two genomes of the two major types of DNA damage induced by UV. Like in humans, (6-4)PP was much more quickly completed compared to CPD in mouse lemur. Both (6-4)PP and CPD repair efficiencies were apparently slower in mouse lemur fibroblasts relative to NHF1 cells. This observation also correlates well with the survival assays which show that mouse lemur cell lines were more sensitive to UV, which contains both damage types. And although this comparison is limited to only two species at present, we postulate that these differences could relate to the diurnal and nocturnal lifestyles of the two species. Given that mouse lemurs are rarely exposed to UV light in nature, there may be some physiological relevance that their damage repair would be less efficient than that seen in humans.</p>
<p>Interestingly, we also observed that TCR was relatively more efficient in mouse lemurs compared to humans especially for CPD repair. TCR of (6-4)PP was not prominent, as was previously shown, and our immunoslot blot assays indicate that (6-4)PP repair is fast and therefore mostly repaired by GR rather than TCR. We observed similar TS and NTS repair signal for (6-4)PP in genic regions, also suggesting that GR is the primary subpathway to repair (6-4)PP. A striking fact is the inverse correlation between TCR, which is measured by TS/NTS repair signal, and overall repair efficiencies. Mouse lemurs with more efficient TCR falls behind in overall repair compared to human. A possible explanation for this observation is that global repair is the main determinant of the repair efficiency. XR-seq yields the entire nucleotide excision repair events with no distinction between TCR and GR. For this reason, GR and TCR efficiencies are relative to each other. Like the relativity in any RNA-seq, which cannot measure the total transcription levels, XR-seq also gives the relative distribution of the repair events. Therefore, measured “TCR efficiency” actually corresponds to “GR deficiency” in XR-seq profile. In other words, when the damage is not efficiently recognized by GR pathway, TCR takes over the recognition and removes DNA lesions in TS. The previously observed high TCR levels in <em>Arabidopsis thaliana</em> <span class="citation" data-cites="12APhIkm8">(Oztas et al. <a href="#ref-12APhIkm8" role="doc-biblioref">2018</a>)</span> and mouse <span class="citation" data-cites="AXdS7vVN">(Yang et al. <a href="#ref-AXdS7vVN" role="doc-biblioref">2018</a>)</span> also suggest relatively poor GR efficiency in those organisms.</p>
<p>Human evolution has been under investigation since the time of Charles Darwin. Comparative analyses between human and other animals has revealed both shared and human-specific features. In the era of molecular biology which began with the discovery of DNA structure in 1953, it has been possible to reveal molecular features as they are shared between humans and their relatives. Primates are an extremely diverse group comprised of species that range in body size from 30-80 grams (mouse lemurs) to 150kg (African apes). Mouse lemurs stand out as the world’s smallest living primate. Given detailed knowledge of primate phylogeny and divergence times <span class="citation" data-cites="QH4z4kb6">(Reis et al. <a href="#ref-QH4z4kb6" role="doc-biblioref">2018</a>)</span>, we know that the most recent common ancestor (MRCA) of humans and mouse lemurs is MRCA of all living primate species, and that this MRCA likely arose near the Cretaceous-Paleogene (K-Pg) boundary 65 mya. Thus, we can reasonably conclude that features that are shared between humans and mouse lemurs are homologous and characteristic of the primate clade.</p>
<p>We have a limited knowledge on the epigenetic architecture of mouse lemurs as we thus far lack chromatin data. Prior to this study, it was unknown whether repair profiles would be similar in the comparison of two primates species. Our work revealed that human and mouse lemur fibroblasts are significantly similar with respect to their preference on which genomic region to repair first. This bias is likely to be caused by the chromatin structure as previously shown in other organisms <span class="citation" data-cites="hJRoVR8L">(Yimit et al. <a href="#ref-hJRoVR8L" role="doc-biblioref">2019</a>)</span>. Damage distribution is known to be homogenous at large genomic scales <span class="citation" data-cites="10FU8PPzJ">(Hu et al. <a href="#ref-10FU8PPzJ" role="doc-biblioref">2017</a><a href="#ref-10FU8PPzJ" role="doc-biblioref">a</a>)</span>. Therefore, it is safe to assume that repair preference is the major factor for XR-seq heterogeneity. The repair profiles of human and mouse lemur fibroblasts are much more similar to each other than the ones between two distinct human cell lines. Moreover, (6-4)PP and CPD repair profiles are more similar to themselves, suggesting similar repair dynamics between two organisms. Further studies on mouse lemur epigenetics will possibly explain the most differentiated genomic repair levels in mouse lemurs. Better understanding mouse lemur genomics, as well as other species within the strepsirrhine clade, will provide additional insight into human evolution, repair and mutagenesis.</p>
<h2 id="methods">Methods</h2>
<h3 id="cell-lines-and-reagents">Cell lines and reagents</h3>
<h4 id="establishment-of-the-immortalized-mouse-lemur-fibroblast-cell-line">Establishment of the immortalized mouse lemur fibroblast cell line</h4>
<p>Primary fibroblasts were established using methods outlined in Larsen and Harris et al <span class="citation" data-cites="1FNsl9JHL">(Larsen et al. <a href="#ref-1FNsl9JHL" role="doc-biblioref">2017</a>)</span>. For the current study, we used an immortalized version of these primary mouse lemur fibroblasts. This cell line was generated by transfecting passage six primary cells at approximately 60% confluency with 5 µg of human hTERT (hTERT) plasmid DNA per well of a 6-well plate using Lipofectamine® 2000 diluted in Opti-MEM® medium. Twenty-four hours post transfection, cells were placed under selection using G418 sulfate at a concentration of 300 µg/mL for two weeks. Selected cells were then plated into a 96-well plate and remained under G418 sulfate maintenance at a concentration of 100 µg/mL to establish single cell colonies. Approximately 2 weeks post transfection, colonies were observed in 19 of the 96 wells and these cells underwent subsequent propagation and expansion.</p>
<h4 id="normal-human-fibroblasts">Normal human fibroblasts</h4>
<p>Telomerase-immortalized normal human fibroblasts (NHF1) were previously described <span class="citation" data-cites="6H2Giv1x OhKg9ZHE">(Heffernan et al. <a href="#ref-6H2Giv1x" role="doc-biblioref">2002</a>; Hu et al. <a href="#ref-OhKg9ZHE" role="doc-biblioref">2015</a>)</span>. All cells were grown in Dulbecco’s modified Eagle’s medium supplemented with 10% fetal bovine serum at 37°C in a 5% CO2 humidified chamber.</p>
<h3 id="clonogenic-survival-assay">Clonogenic Survival Assay</h3>
<p>Cells were seeded in 10 cm plates at 300 cells/plate, grown for 16 hours, and then UV irradiated as follows. After removing and reserving culture medium, cells were placed under a GE germicidal lamp that emits primarily 254-nm UV light (UV-C) at 1 Jm<span class="math inline">\(^2\)</span>/sec connected to a digital timer to give the indicated dose. Following irradiation, the culture medium was replaced, and the cells were incubated for 7 days. Plates were then washed with phosphate-buffered saline (PBS), the cells were fixed for 10 min in 75% methanol/25% acetic acid, and stained with 0.5% crystal violet stain (J.T. Baker) in 25% methanol for 30 min. The plates were then washed extensively in tap water to remove the excess stain. After drying, images of the stained cells were taken on a Molecular Imager Chemi-Doc XRS+ system (Bio-Rad) for presentation of representative, qualitative results. Colonies were counted and the surviving fraction was calculated by dividing the number of colonies on treated plates by the number on the untreated plates. Each condition was performed in triplicate and the experiment was repeated three independent times.</p>
<h3 id="immunoslot-blot-analysis">Immunoslot Blot Analysis</h3>
<p>Repair of UV photoproducts from genomic DNA was measured as described previously <span class="citation" data-cites="1Cn9oXJVt">(Gaddameedhi et al. <a href="#ref-1Cn9oXJVt" role="doc-biblioref">2010</a>)</span>. Cells were UV irradiated as described above for a dose of 10J/m<span class="math inline">\(^2\)</span>. Following irradiation, the culture medium was replaced, and the cells were incubated for the indicated periods of time. Genomic DNA (250 ng), isolated with a QIAamp DNA Mini kit (Qiagen), was immobilized on a nitrocellulose membrane with a Bio-Dot SF Cell immunoslot blot apparatus (Bio-Rad) and heated for 90 min at 80 °C under vacuum. Blots were blocked in 5% milk and probed with an anti-(6-4)PP antibody (Cosmo Bio 64M-2 cat#NM-DND-001) or anti-CPD antibody (Cosmo Bio TDM-2 cat#NM-DND-002) as indicated. The secondary antibody was horseradish peroxidase-linked anti-mouse IgG from GE Healthcare (catalog no. NA931V) and the chemiluminescent signals were visualized with Clarity Western ECL Substrate (Bio-Rad) and using a Molecular Imager Chemi-Doc XRS+ system (Bio-Rad). Following immunoblotting, the blots were re-blotted with anti-ssDNA antibody (Millipore MAB3034 clone 16-19) to ensure equal loading of DNA. The experiment was repeated three times, and representative results are presented.</p>
<h3 id="detection-of-excised-oligonucleotide-products-of-nucleotide-excision-repair">Detection of Excised Oligonucleotide Products of Nucleotide Excision Repair</h3>
<p>Nucleotide excision repair activity was visualized as previously described <span class="citation" data-cites="1GUFhcYbP">(Hu et al. <a href="#ref-1GUFhcYbP" role="doc-biblioref">2013</a>)</span>. Cells grown to ~80% confluency in 15-cm plates were harvested the indicated time after irradiation with 20 J/m<span class="math inline">\(^2\)</span> of UV. The cells were pelleted by centrifugation, subjected to a modified Hirt procedure where cell pellets were resuspended in a 10× packed cell volume of lysis buffer (50 mM Tris-Cl, pH 8.0, 10 mM EDTA, 1.2% SDS and 100 μg/ml RNase A) and incubated for 15 min at room temperature. Following addition of a one-fourth volume of 5 M NaCl, the mixtures were gently mixed and incubated on ice for &gt;16 h. After centrifugation at maximum speed (20,000 × g) for 1 h, the supernatants were gently transferred to new tubes and treated with 20 μg of proteinase K for 15 min at 55 °C, extracted with phenol/chloroform, and then precipitated with ethanol. The pellet was washed with 500 μl of 70% ethanol and resuspended in 10 μl of buffer EB (10 mM Tris-Cl (pH8.5)). The excised oligonucleotide products of nucleotide excision repair were purified from the remaining material with either anti-(6-4)PP or anti-CPD antibodies as follows: For each reaction, 5 μl of protein G Dynabeads (Invitrogen, catalog no. 10003D) slurry and 5 μl of anti-rabbit Dynabeads (Invitrogen, catalog no. 11203D) slurry were washed three times with 50 μl of wash buffer I (20 mM Tris-Cl (pH 8.0), 2 mM EDTA, 150 mM NaCl, 1% Triton X-100, and 0.1% SDS) and then incubated with 1 μl of rabbit anti-mouse IgG and 1 μl of anti-(6-4)PP or anti-CPD antibody in 20 μl of IP buffer (20 mM Tris-Cl (pH 8.0), 2 mM EDTA, 150 mM NaCl, 1% Triton X-100, and 0.5% sodium deoxycholate) for 3 h at 4 °C. After incubation, beads were separated from the liquid with a magnet and then mixed with 100 μl of IP buffer and 10 μl of DNA. The mixtures were rotated at 4 °C overnight. The beads were then washed sequentially with 200 μl each of wash buffer I, wash buffer II (20 mM Tris-Cl (pH 8.0), 2 mM EDTA, 500 mM NaCl, 1% Triton X-100, and 0.1% SDS), wash buffer III (10 mM Tris-Cl (pH 8.0), 1 mM EDTA, 150 mM LiCl, 1% Nonidet P-40, and 1% sodium deoxycholate), wash buffer IV (100 mM Tris-Cl (pH 8.0), 1 mM EDTA, 500 mM LiCl, 1% Nonidet P-40, and 1% sodium deoxycholate) and finally twice with TE (10 mM Tris-Cl (pH 8.0) and 1 mM EDTA). The oligonucleotides containing UV photoproducts were eluted by incubation with 100 μl of elution buffer (50 mM NaHCO3, 1% SDS, and 20 μg/ml glycogen) at 65 °C for 15 min. The eluted DNA was then isolated by phenol/chloroform extraction and followed by ethanol precipitation. The excised oligonucleotides were resuspended in 10 μl of water, and half of the DNA was 3′-end labeled for 1 h at 37 °C in a 10-μl reaction containing 6 units of terminal deoxynucleotidyl transferase (New England Biolabs), 0.25 mM CoCl2, and 1 μCi of [α-32P]-3′-deoxyadenosine 5′-triphosphate (cordycepin 5′-triphosphate, Perkin Elmer Life Sciences) in 1× terminal deoxynucleotidyl transferase buffer (New England Biolabs). 2.5 fmol of a 50-nucleotide oligomer was included in all reactions as an internal control, and oligonucleotides of known length were resolved on all gels as size markers. Following phenol-chloroform extraction and ethanol precipitation, the DNA was separated on urea-containing polyacrylamide gels, detected with a phosphorimager and was quantified using ImageQuant software (version 5.2, GE Healthcare). The experiment was repeated three times.</p>
<h3 id="xr-seq-library-preparation">XR-seq library preparation</h3>
<p>Samples were processed for XR-seq as previously described <span class="citation" data-cites="FND0ibVT">(Hu et al. <a href="#ref-FND0ibVT" role="doc-biblioref">2018</a>)</span>. Cells grown to ~80% confluency in 15-cm plates were harvested either 5 minutes or 1 h after irradiation with 20 J/m<span class="math inline">\(^2\)</span> of UV, depending on the damage, (6-4)PP or CPD respectively, to be analyzed. Samples from four plates were pooled, lysed, and immunoprecipitated with anti-TFIIH antibodies p62 (Santa Cruz Biotechnology, sc292) and p89 (XPB, Santa Cruz Biotechnology, sc293), and then ligated to adapters and processed for sequencing.</p>
<h3 id="rna-seq-library-preparation">RNA-seq library preparation</h3>
<p>Total RNA was isolated from one 10-cm plate of exponentially growing NHF1 or Lemur cells using Trizol (Invitrogen) and the RNeasy Mini Kit (Qiagen) following the manufacturer’s instructions. The library preparation and strand-specific paired-end sequencing (2 × 150 bp) on a HiSeq 4000 platform (Illumina) was performed by Novogene Co., Ltd.</p>
<h3 id="human-and-lemur-genome-alignment">Human and lemur genome alignment</h3>
<p>MUMmer version 3.23 <span class="citation" data-cites="NR7S6TEE">(Kurtz et al. <a href="#ref-NR7S6TEE" role="doc-biblioref">2004</a>)</span> was used to align grey mouse lemur genome (Mmur_3.0) to human genome (hg19) with <code>nucmer</code> subprogram. The alignments were filtered based on criteria taking length and identity into account. Alignments were listed in “delta format” by default by Nucmer. For every reference (human) - query (lemur) pair, we kept the alignments which form the longest mutually consistent set. Filtering step was performed with <code>delta-filter</code> subprogram. <code>show-coords</code> subprogram was used to display summary information such as position, percent identity and other features of each alignment, in Btab format with <code>-B</code> and <code>-rclo</code> arguements.</p>
<p>We used <code>generateBED.R</code> <span class="citation" data-cites="ZvXLvNIS">(Akkose et al. <a href="#ref-ZvXLvNIS" role="doc-biblioref">2019</a>)</span> to write homologous human-lemur regions in a bed file. Due to low genome coverage in XR-seq data sets small regions introduce random repair values. Since we were not interested in too short alignments, we filtered out alignments shorter than 400 bp while generating the bed file. Additionally, alignments with at percent similarity lower than 80 were filtered out of the list. Resulting was a BED file with each homologus region between two genomes.</p>
<p>This output file contained regions in either genome that align to multiple regions in the other genome. To remove such regions, we used, we used <code>bedtools intersect</code> <span class="citation" data-cites="1HWiAHnIw">(Quinlan and Hall <a href="#ref-1HWiAHnIw" role="doc-biblioref">2010</a>)</span> to intersect the file with itself. The command line we used was: <code>bedtools intersect -wo -s -a humanOverlapsLemur_short_noFilter.bed -b humanOverlapsLemur_short_noFilter.bed &gt; human_intersect.txt</code>. We compared this intersected output file to the <code>bed</code> file generated previously using <code>findDupAln.R</code> <span class="citation" data-cites="ZvXLvNIS">(Akkose et al. <a href="#ref-ZvXLvNIS" role="doc-biblioref">2019</a>)</span> to exclude regions in both genomes that align to multiple regions in other genome. This resulted in a <code>bed</code> file of one-to-one homologous regions without multiple alignments for one region.</p>
<h3 id="xr-seq-analysis">XR-seq analysis</h3>
<p>We trimmed 3’ adapter sequences (TGGAATTCTCGGGTGCCAAGGAACTCCAGTNNNNNNACGATCTCGTATGCCGTCTTCTGCTTG) using Cutadapt <span class="citation" data-cites="1Fp9ui2nK">(Martin <a href="#ref-1Fp9ui2nK" role="doc-biblioref">2011</a>)</span>. Bowtie2 version 2.3.4.1 <span class="citation" data-cites="PiS0h6Mu">(Langmead and Salzberg <a href="#ref-PiS0h6Mu" role="doc-biblioref">2012</a>)</span> was used to align sequencing reads onto reference genomes with default parameters. With a two-step conversion process, the <code>sam</code> format was first converted (with SAMtools <span class="citation" data-cites="IPc8cy7s">(Li et al. <a href="#ref-IPc8cy7s" role="doc-biblioref">2009</a>)</span>) to <code>bam</code> format, which was then converted to <code>bed</code> format with BEDTools <span class="citation" data-cites="1HWiAHnIw">(Quinlan and Hall <a href="#ref-1HWiAHnIw" role="doc-biblioref">2010</a>)</span>. The resulting <code>bed</code> files were sorted by coordinates and duplicate regions were removed. Command line we used was: <code>sort -u -k1,1 -k2,2n -k3,3n ${SAMPLE}_cutadapt.bed &gt;${SAMPLE}_cutadapt_sorted.bed</code></p>
<h3 id="rna-seq-analysis">RNA-seq analysis</h3>
<p>Sequencing reads were aligned to reference genome using STAR Aligner 2.6.1a <span class="citation" data-cites="tTu8Ds9Z">(Dobin et al. <a href="#ref-tTu8Ds9Z" role="doc-biblioref">2012</a>)</span> with default parameters. The aligned reads were converted to <code>bed</code> format with <code>bedtools bamtobed</code>. The resulting <code>bed</code> files were sorted by coordinates and duplicate regions were removed. Command line we used was: <code>sort -u -k1,1 -k2,2n -k3,3n ${SAMPLE}.bed &gt;${SAMPLE}_sorted.bed</code></p>
<h3 id="xr-seq-simulation">XR-seq simulation</h3>
<p>We evaluated the correlation of repair mechanisms with both simulated and real XR-seq datasets. Simulated datasets were generated for the overlapping regions between grey mouse lemur genome and human genome using ART simulator <span class="citation" data-cites="znONJtTo">(Huang et al. <a href="#ref-znONJtTo" role="doc-biblioref">2011</a>)</span>. We used <code>bedtools getfasta</code> program with the <code>bed</code> file containing homologus regions between two organisms to generate a reference <code>fasta</code> file for ART simulator to produce synthetic reads. By default ART simulator produces a <code>fastq</code> file with flat nucleotide distribution. For a better representation of XR-seq characteristics in simulated dataset, we obtain nucleotide distribution frequencies of both species XR-seq reads. We applied a scoring function where each nucleotide in the simulated read was scored based on the frequency of that nucleotide to be in that position in real dataset and obtained a total score for each simulated read. Accordingly, best scoring 10 million reads were selected for both species from the simulated dataset with using <code>filter_syn.go</code> <span class="citation" data-cites="ZvXLvNIS">(Akkose et al. <a href="#ref-ZvXLvNIS" role="doc-biblioref">2019</a>)</span></p>
<h3 id="downstream-analysis">Downstream Analysis</h3>
<p>To calculate nucleotide frequencies of excised oligomers we first converted aligned Xr-seq reads to <code>fasta</code> format using <code>bedtools getfasta</code>. Then using <code>frequency.go</code> <span class="citation" data-cites="ZvXLvNIS">(Akkose et al. <a href="#ref-ZvXLvNIS" role="doc-biblioref">2019</a>)</span> we calculated nucleotide frequency of predominant oligomer (26nt) for each primate and damage type.</p>
<p>Command line used to get excised oligomer lengths: <code>awk '{print $3-$2}' ${SAMPLE}_cutadapt_sorted.bed | sort -k1,1n | uniq -c | sed 's/\s\s*/ /g' | awk '{print $2"\t"$1}'</code></p>
<p>For both genomes all annotated protein-coding genes were retrieved and genes that are closer to each other with less than 20kb were filtered out. We used 5277 and 3366 number of genes for human and mouse lemur, respectively. 10 kb upstream and downstream of TSS and TES were divided into 100 bp windows. XR-seq reads falling onto each bin were normalized to RPKM with <code>tcr.py</code> <span class="citation" data-cites="ZvXLvNIS">(Akkose et al. <a href="#ref-ZvXLvNIS" role="doc-biblioref">2019</a>)</span> Then XR-seq RPKM values were normalized by the RPKM values derived by the mapped reads onto random genomic sites which are prepared using <code>bedtools shuffle</code> for protein-coding genes that are not closer to each other with less than 20kb.</p>
<p>We used <code>regions_rpkm.go</code> <span class="citation" data-cites="ZvXLvNIS">(Akkose et al. <a href="#ref-ZvXLvNIS" role="doc-biblioref">2019</a>)</span> to calculate RPKM values of XR-seq, RNA-seq, and simulated XR-seq for each overlapping region. Regions with no XR-seq or RNA-seq reads were filtered out.</p>
<p>Circos plot for comprehensive summarization of all findings has been generated with <code>circosPlot.R</code> <span class="citation" data-cites="ZvXLvNIS">(Akkose et al. <a href="#ref-ZvXLvNIS" role="doc-biblioref">2019</a>)</span> by using R package <code>circlize</code>.<span class="citation" data-cites="uO1r94Ec">(Gu et al. <a href="#ref-uO1r94Ec" role="doc-biblioref">2014</a>)</span></p>
<p>PCA plot has been generated from read counts with <code>plotPCA.R</code> <span class="citation" data-cites="ZvXLvNIS">(Akkose et al. <a href="#ref-ZvXLvNIS" role="doc-biblioref">2019</a>)</span>, while applying variance stabilizing transformation as described in DESeq2 <span class="citation" data-cites="w9AOzBMw">(Love et al. <a href="#ref-w9AOzBMw" role="doc-biblioref">2014</a>)</span> vignette.</p>
<p>Plots were prepared using <code>plotly</code> and <code>ggplot2</code><span class="citation" data-cites="7F5oVreR">(Villanueva and Chen <a href="#ref-7F5oVreR" role="doc-biblioref">2019</a>)</span>.</p>
<h2 id="data-access">Data Access</h2>
<p>All raw and processed sequencing data generated in this study have been submitted to the NCBI Gene Expression Omnibus (GEO; https://www.ncbi.nlm.nih.gov/geo/) under accession number GSE145883.</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>This work is supported by National Institutes of Health grants GM118102 and ES027255 to AS. ADY was supported by NSF DEB-1354610, the John Simon Guggenheim Foundation, and the Alexander von Humboldt Foundation. OA is supported by EMBO Installation Grant (funded by TUBITAK: The Scientific and Technological Research Council of Turkey) and by TUBITAK 2232 International Fellowship for Outstanding Researchers Program. OA received a research grant as a recepient of Young Scientist Award (BAGEP) given by Science Acadamey, Turkey. OA also recieved personal research funds by Sabanci University. We would like to thank Dr. Beth A Sullivan for the construct to make the TERT-immortalized lines. The manuscript was written using Manubot <span class="citation" data-cites="YuJbg3zO">(Himmelstein et al. <a href="#ref-YuJbg3zO" role="doc-biblioref">2019</a>)</span>.</p>
<p><em>Authors’ contributions:</em> OA, AS, LL-B and ADY conceived of the project and designed the experiments. Mouse lemur tissue was acquired by ADY and PAL, cell lines were prepared by AB providing reagents for immortalization (hTERT construct). LL-B performed experimental assays, XR-seq and RNA-seq experiments. VOK, UA and ZK performed computational analyses. OA interpreted the data and wrote the first draft. All authors have read, revised and approved the final manuscript.</p>
<h2 id="disclosure-declaration">Disclosure Declaration</h2>
<!-- ## Competing interests -->
<p>The authors declare that there is no conflict of interest regarding the publication of this article.</p>
<h2 class="page_break_before" id="references" class="page_break_before">References</h2>
<!-- Explicitly insert bibliography here -->
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-4WTs70ml">
<p>Adar S, Hu J, Lieb JD, Sancar A. 2016. Genome-wide kinetics of DNA excision repair in relation to chromatin state and mutagenesis. <em>Proc Natl Acad Sci USA</em> <strong>113</strong>: E2124–E2133. <a href="https://doi.org/f8g4ps">https://doi.org/f8g4ps</a>.</p>
</div>
<div id="ref-18edpunap">
<p>Adebali O, Chiou Y-Y, Hu J, Sancar A, Selby CP. 2017a. Genome-wide transcription-coupled repair in Escherichia coli is mediated by the Mfd translocase. <em>Proc Natl Acad Sci USA</em> <strong>114</strong>: E2116–E2125. <a href="https://doi.org/f9v7nt">https://doi.org/f9v7nt</a>.</p>
</div>
<div id="ref-1190rUeCp">
<p>Adebali O, Sancar A, Selby CP. 2017b. Mfd translocase is necessary and sufficient for transcription-coupled repair inEscherichia coli. <em>J Biol Chem</em> <strong>292</strong>: 18386–18391. <a href="https://doi.org/ggdfwv">https://doi.org/ggdfwv</a>.</p>
</div>
<div id="ref-ZvXLvNIS">
<p>Akkose U, Kaya VO, Karagoz Z, Adebali O. 2019. compGenomeLab/lemurRepair GitHub repository. <em>GitHub</em>. <a href="https://github.com/compGenomeLab/lemurRepair">https://github.com/compGenomeLab/lemurRepair</a>.</p>
</div>
<div id="ref-CoujlGZF">
<p>Blanco MB, Rasoazanabary E, Godfrey LR. 2015. Unpredictable environments, opportunistic responses: Reproduction and population turnover in two wild mouse lemur species (Microcebus rufusandM. griseorufus) from eastern and western Madagascar. <em>Am J Primatol</em> <strong>77</strong>: 936–947. <a href="https://doi.org/f7n2hd">https://doi.org/f7n2hd</a>.</p>
</div>
<div id="ref-iyn6rN7q">
<p>Deger N, Yang Y, Lindsey-Boltz LA, Sancar A, Selby CP. 2019. Drosophila, which lacks canonical transcription-coupled repair proteins, performs transcription-coupled repair. <em>J Biol Chem</em> <strong>294</strong>: 18092–18098. <a href="https://doi.org/ggdfwt">https://doi.org/ggdfwt</a>.</p>
</div>
<div id="ref-tTu8Ds9Z">
<p>Dobin A, Davis CA, Schlesinger F, Drenkow J, Zaleski C, Jha S, Batut P, Chaisson M, Gingeras TR. 2012. STAR: ultrafast universal RNA-seq aligner. <em>Bioinformatics</em> <strong>29</strong>: 15–21. <a href="https://doi.org/f4h523">https://doi.org/f4h523</a>.</p>
</div>
<div id="ref-fKeXK6h7">
<p>Ezran C, Karanewsky CJ, Pendleton JL, Sholtz A, Krasnow MR, Willick J, Razafindrakoto A, Zohdy S, Albertelli MA, Krasnow MA. 2017. The Mouse Lemur, a Genetic Model Organism for Primate Biology, Behavior, and Health. <em>Genetics</em> <strong>206</strong>: 651–664. <a href="https://doi.org/gbh929">https://doi.org/gbh929</a>.</p>
</div>
<div id="ref-1Cn9oXJVt">
<p>Gaddameedhi S, Kemp MG, Reardon JT, Shields JM, Smith-Roe SL, Kaufmann WK, Sancar A. 2010. Similar Nucleotide Excision Repair Capacity in Melanocytes and Melanoma Cells. <em>Cancer Res</em> <strong>70</strong>: 4922–4930. <a href="https://doi.org/cv5w99">https://doi.org/cv5w99</a>.</p>
</div>
<div id="ref-uO1r94Ec">
<p>Gu Z, Gu L, Eils R, Schlesner M, Brors B. 2014. circlize implements and enhances circular visualization in R. <em>Bioinformatics</em> <strong>30</strong>: 2811–2812. <a href="https://doi.org/f6ktws">https://doi.org/f6ktws</a>.</p>
</div>
<div id="ref-29W7k2UV">
<p>Hanawalt PC, Spivak G. 2008. Transcription-coupled DNA repair: two decades of progress and surprises. <em>Nat Rev Mol Cell Biol</em> <strong>9</strong>: 958–970. <a href="https://doi.org/brt6w7">https://doi.org/brt6w7</a>.</p>
</div>
<div id="ref-6H2Giv1x">
<p>Heffernan TP, Simpson DA, Frank AR, Heinloth AN, Paules RS, Cordeiro-Stone M, Kaufmann WK. 2002. An ATR- and Chk1-Dependent S Checkpoint Inhibits Replicon Initiation following UVC-Induced DNA Damage. <em>Molecular and Cellular Biology</em> <strong>22</strong>: 8552–8561. <a href="https://doi.org/d5q4pz">https://doi.org/d5q4pz</a>.</p>
</div>
<div id="ref-YuJbg3zO">
<p>Himmelstein DS, Rubinetti V, Slochower DR, Hu D, Malladi VS, Greene CS, Gitter A. 2019. Open collaborative writing with Manubot ed. D. Schneidman-Duhovny. <em>PLoS Comput Biol</em> <strong>15</strong>: e1007128. <a href="https://doi.org/c7np">https://doi.org/c7np</a>.</p>
</div>
<div id="ref-1Gbi7LeDk">
<p>Horvath JE, Willard HF. 2007. Primate comparative genomics: lemur biology and evolution. <em>Trends in Genetics</em> <strong>23</strong>: 173–182. <a href="https://doi.org/bwv8j4">https://doi.org/bwv8j4</a>.</p>
</div>
<div id="ref-OhKg9ZHE">
<p>Hu J, Adar S, Selby CP, Lieb JD, Sancar A. 2015. Genome-wide analysis of human global and transcription-coupled excision repair of UV damage at single-nucleotide resolution. <em>Genes Dev</em> <strong>29</strong>: 948–960. <a href="https://doi.org/f69xk2">https://doi.org/f69xk2</a>.</p>
</div>
<div id="ref-10FU8PPzJ">
<p>Hu J, Adebali O, Adar S, Sancar A. 2017a. Dynamic maps of UV damage formation and repair for the human genome. <em>Proc Natl Acad Sci USA</em> 201706522. <a href="https://doi.org/ggdfws">https://doi.org/ggdfws</a>.</p>
</div>
<div id="ref-1GUFhcYbP">
<p>Hu J, Choi J-H, Gaddameedhi S, Kemp MG, Reardon JT, Sancar A. 2013. Nucleotide Excision Repair in Human Cells. <em>J Biol Chem</em> <strong>288</strong>: 20918–20926. <a href="https://doi.org/f46nq2">https://doi.org/f46nq2</a>.</p>
</div>
<div id="ref-FND0ibVT">
<p>Hu J, Li W, Adebali O, Yang Y, Oztas O, Selby CP, Sancar A. 2018. Genome-wide mapping of nucleotide excision repair with XR-seq. <em>Nat Protoc</em> <strong>14</strong>: 248–282. <a href="https://doi.org/ggkvth">https://doi.org/ggkvth</a>.</p>
</div>
<div id="ref-ZAV7FWhL">
<p>Hu J, Lieb JD, Sancar A, Adar S. 2016. Cisplatin DNA damage and repair maps of the human genome at single-nucleotide resolution. <em>Proc Natl Acad Sci USA</em> <strong>113</strong>: 11507–11512. <a href="https://doi.org/f86sdj">https://doi.org/f86sdj</a>.</p>
</div>
<div id="ref-bYJTOmGw">
<p>Hu J, Selby CP, Adar S, Adebali O, Sancar A. 2017b. Molecular mechanisms and genomic maps of DNA excision repair inEscherichia coliand humans. <em>J Biol Chem</em> <strong>292</strong>: 15588–15597. <a href="https://doi.org/gftwfh">https://doi.org/gftwfh</a>.</p>
</div>
<div id="ref-RCFCwjid">
<p>Huang JC, Svoboda DL, Reardon JT, Sancar A. 1992. Human nucleotide excision nuclease removes thymine dimers from DNA by incising the 22nd phosphodiester bond 5’ and the 6th phosphodiester bond 3’ to the photodimer. <em>Proceedings of the National Academy of Sciences</em> <strong>89</strong>: 3664–3668. <a href="https://doi.org/c8cz9k">https://doi.org/c8cz9k</a>.</p>
</div>
<div id="ref-znONJtTo">
<p>Huang W, Li L, Myers JR, Marth GT. 2011. ART: a next-generation sequencing read simulator. <em>Bioinformatics</em> <strong>28</strong>: 593–594. <a href="https://doi.org/fzf84c">https://doi.org/fzf84c</a>.</p>
</div>
<div id="ref-NR7S6TEE">
<p>Kurtz S, Phillippy A, Delcher AL, Smoot M, Shumway M, Antonescu C, Salzberg SL. 2004. <em>Genome Biol</em> <strong>5</strong>: R12. <a href="https://doi.org/fprdqc">https://doi.org/fprdqc</a>.</p>
</div>
<div id="ref-PiS0h6Mu">
<p>Langmead B, Salzberg SL. 2012. Fast gapped-read alignment with Bowtie 2. <em>Nat Methods</em> <strong>9</strong>: 357–359. <a href="https://doi.org/gd2xzn">https://doi.org/gd2xzn</a>.</p>
</div>
<div id="ref-1FNsl9JHL">
<p>Larsen PA, Harris RA, Liu Y, Murali SC, Campbell CR, Brown AD, Sullivan BA, Shelton J, Brown SJ, Raveendran M, et al. 2017. Hybrid de novo genome assembly and centromere characterization of the gray mouse lemur (Microcebus murinus). <em>BMC Biol</em> <strong>15</strong>. <a href="https://doi.org/ggdf3h">https://doi.org/ggdf3h</a>.</p>
</div>
<div id="ref-IPc8cy7s">
<p>Li H, Handsaker B, Wysoker A, Fennell T, Ruan J, Homer N, Marth G, Abecasis G, Durbin R,. 2009. The Sequence Alignment/Map format and SAMtools. <em>Bioinformatics</em> <strong>25</strong>: 2078–2079. <a href="https://doi.org/ff6426">https://doi.org/ff6426</a>.</p>
</div>
<div id="ref-OSVE68co">
<p>Li W, Adebali O, Yang Y, Selby CP, Sancar A. 2018. Single-nucleotide resolution dynamic repair maps of UV damage in Saccharomyces cerevisiae genome. <em>Proc Natl Acad Sci USA</em> <strong>115</strong>: E3408–E3415. <a href="https://doi.org/gdc9gh">https://doi.org/gdc9gh</a>.</p>
</div>
<div id="ref-cZtF6zIe">
<p>Li W, Sancar A. 2020. Methodologies for Detecting Environmentally‐Induced DNA Damage and Repair. <em>Environ Mol Mutagen</em>. <a href="https://doi.org/ggmr42">https://doi.org/ggmr42</a>.</p>
</div>
<div id="ref-w9AOzBMw">
<p>Love MI, Huber W, Anders S. 2014. Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2. <em>Genome Biol</em> <strong>15</strong>. <a href="https://doi.org/gd3zvn">https://doi.org/gd3zvn</a>.</p>
</div>
<div id="ref-zxIvoFqn">
<p>Mao P, Brown AJ, Esaki S, Lockwood S, Poon GMK, Smerdon MJ, Roberts SA, Wyrick JJ. 2018. ETS transcription factors induce a unique UV damage signature that drives recurrent mutagenesis in melanoma. <em>Nat Commun</em> <strong>9</strong>. <a href="https://doi.org/gdxcvk">https://doi.org/gdxcvk</a>.</p>
</div>
<div id="ref-1Fp9ui2nK">
<p>Martin M. 2011. Cutadapt removes adapter sequences from high-throughput sequencing reads. <em>EMBnet j</em> <strong>17</strong>: 10. <a href="https://doi.org/gdh7xt">https://doi.org/gdh7xt</a>.</p>
</div>
<div id="ref-NkhwUBAb">
<p>Mellon I, Hanawalt PC. 1989. Induction of the Escherichia coli lactose operon selectively increases repair of its transcribed DNA strand. <em>Nature</em> <strong>342</strong>: 95–98. <a href="https://doi.org/c9gdjm">https://doi.org/c9gdjm</a>.</p>
</div>
<div id="ref-12APhIkm8">
<p>Oztas O, Selby CP, Sancar A, Adebali O. 2018. Genome-wide excision repair in Arabidopsis is coupled to transcription and reflects circadian gene expression patterns. <em>Nat Commun</em> <strong>9</strong>. <a href="https://doi.org/gdd6q4">https://doi.org/gdd6q4</a>.</p>
</div>
<div id="ref-1HWiAHnIw">
<p>Quinlan AR, Hall IM. 2010. BEDTools: a flexible suite of utilities for comparing genomic features. <em>Bioinformatics</em> <strong>26</strong>: 841–842. <a href="https://doi.org/cmrms3">https://doi.org/cmrms3</a>.</p>
</div>
<div id="ref-QH4z4kb6">
<p>Reis MD, Gunnell GF, Barba-Montoya J, Wilkins A, Yang Z, Yoder AD. 2018. Using Phylogenomic Data to Explore the Effects of Relaxed Clocks and Calibration Strategies on Divergence Time Estimation: Primates as a Test Case ed. S. Ho. <em>Systematic Biology</em> <strong>67</strong>: 594–615. <a href="https://doi.org/gct4ft">https://doi.org/gct4ft</a>.</p>
</div>
<div id="ref-uOxe2lBD">
<p>Sancar A, Rupp WD. 1983. A novel repair enzyme: UVRABC excision nuclease of Escherichia coli cuts a DNA strand on both sides of the damaged region. <em>Cell</em> <strong>33</strong>: 249–60. <a href="https://www.ncbi.nlm.nih.gov/pubmed/6380755">https://www.ncbi.nlm.nih.gov/pubmed/6380755</a>.</p>
</div>
<div id="ref-LyGwcDX7">
<p>Steurer B, Turkyilmaz Y, van Toorn M, van Leeuwen W, Escudero-Ferruz P, Marteijn JA. 2019. Fluorescently-labelled CPD and 6-4PP photolyases: new tools for live-cell DNA damage quantification and laser-assisted repair. <em>Nucleic Acids Research</em> <strong>47</strong>: 3536–3549. <a href="https://doi.org/ggkszp">https://doi.org/ggkszp</a>.</p>
</div>
<div id="ref-7F5oVreR">
<p>Villanueva RAM, Chen ZJ. 2019. ggplot2: Elegant Graphics for Data Analysis (2nd ed.). <em>Measurement: Interdisciplinary Research and Perspectives</em> <strong>17</strong>: 160–167. <a href="https://doi.org/ggqrmf">https://doi.org/ggqrmf</a>.</p>
</div>
<div id="ref-AXdS7vVN">
<p>Yang Y, Adebali O, Wu G, Selby CP, Chiou Y-Y, Rashid N, Hu J, Hogenesch JB, Sancar A. 2018. Cisplatin-DNA adduct repair of transcribed genes is controlled by two circadian programs in mouse tissues. <em>Proc Natl Acad Sci USA</em> <strong>115</strong>: E4777–E4785. <a href="https://doi.org/gdk8bg">https://doi.org/gdk8bg</a>.</p>
</div>
<div id="ref-hJRoVR8L">
<p>Yimit A, Adebali O, Sancar A, Jiang Y. 2019. Differential damage and repair of DNA-adducts induced by anti-cancer drug cisplatin across mouse organs. <em>Nat Commun</em> <strong>10</strong>. <a href="https://doi.org/ggh7vb">https://doi.org/ggh7vb</a>.</p>
</div>
</div>
<h2 class="page_break_before" id="supplementary-materials" class="page_break_before">Supplementary Materials</h2>
<div id="fig:S1" class="fignos">
<figure>
<img src="images/simulation.png" data-tag="S1" alt="" /><figcaption><span>Figure S1:</span> Nucleotide content of simulated XR-seq pseudo-oligomers.</figcaption>
</figure>
</div>
<div id="fig:S2" class="fignos">
<figure>
<img src="images/Human_RNA_64.png" data-tag="S2" alt="" /><figcaption><span>Figure S2:</span> Human and mouse lemur (6-4)PP repair correlation in human transcription quartiles.</figcaption>
</figure>
</div>
<div id="fig:S3" class="fignos">
<figure>
<img src="images/Lemur_RNA_64.png" data-tag="S3" alt="" /><figcaption><span>Figure S3:</span> Human and mouse lemur (6-4)PP repair correlation in mouse lemur transcription quartiles.</figcaption>
</figure>
</div>
<div id="fig:S4" class="fignos">
<figure>
<img src="images/Human_RNA_CPD.png" data-tag="S4" alt="" /><figcaption><span>Figure S4:</span> Human and mouse lemur CPD repair correlation in human transcription quartiles.</figcaption>
</figure>
</div>
<div id="fig:S5" class="fignos">
<figure>
<img src="images/Lemur_RNA_CPD.png" data-tag="S5" alt="" /><figcaption><span>Figure S5:</span> Human and mouse lemur CPD repair correlation in mouse lemur transcription quartiles.</figcaption>
</figure>
</div>
<!-- default theme -->

<style>
    /* import google fonts */
    @import url("https://fonts.googleapis.com/css?family=Open+Sans:400,600,700");
    @import url("https://fonts.googleapis.com/css?family=Source+Code+Pro");

    /* -------------------------------------------------- */
    /* global */
    /* -------------------------------------------------- */

    /* all elements */
    * {
        /* force sans-serif font unless specified otherwise */
        font-family: "Open Sans", "Helvetica", sans-serif;

        /* prevent text inflation on some mobile browsers */
        -webkit-text-size-adjust: none !important;
        -moz-text-size-adjust: none !important;
        -o-text-size-adjust: none !important;
        text-size-adjust: none !important;
    }

    @media only screen {
        /* "page" element */
        body {
            position: relative;
            box-sizing: border-box;
            font-size: 12pt;
            line-height: 1.5;
            max-width: 8.5in;
            margin: 20px auto;
            padding: 40px;
            border-radius: 5px;
            border: solid 1px #bdbdbd;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            background: #ffffff;
        }
    }

    /* when on screen < 8.5in wide */
    @media only screen and (max-width: 8.5in) {
        /* "page" element */
        body {
            padding: 20px;
            margin: 0;
            border-radius: 0;
            border: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05) inset;
            background: none;
        }
    }

    /* -------------------------------------------------- */
    /* headings */
    /* -------------------------------------------------- */

    /* all headings */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        margin: 20px 0;
        padding: 0;
        font-weight: bold;
    }

    /* biggest heading */
    h1 {
        margin: 40px 0;
        text-align: center;
    }

    /* second biggest heading */
    h2 {
        margin-top: 30px;
        padding-bottom: 5px;
        border-bottom: solid 1px #bdbdbd;
    }

    /* -------------------------------------------------- */
    /* manuscript header */
    /* -------------------------------------------------- */

    /* manuscript title */
    header > h1 {
        margin: 0;
    }

    /* manuscript title caption text (ie "automatically generated on") */
    header + p {
        text-align: center;
        margin-top: 10px;
    }

    /* -------------------------------------------------- */
    /* text elements */
    /* -------------------------------------------------- */

    /* links */
    a {
        color: #2196f3;
        overflow-wrap: break-word;
    }

    /* normal links (not empty, not button link, not syntax highlighting link) */
    a:not(:empty):not(.button):not(.sourceLine) {
        padding-left: 1px;
        padding-right: 1px;
    }

    /* superscripts and subscripts */
    sub,
    sup {
        /* prevent from affecting line height */
        line-height: 0;
    }

    /* unordered and ordered lists*/
    ul,
    ol {
        padding-left: 20px;
    }

    /* class for styling text semibold */
    .semibold {
        font-weight: 600;
    }

    /* class for styling elements horizontally left aligned */
    .left {
        display: block;
        text-align: left;
        margin-left: auto;
        margin-right: 0;
        justify-content: left;
    }

    /* class for styling elements horizontally centered */
    .center {
        display: block;
        text-align: center;
        margin-left: auto;
        margin-right: auto;
        justify-content: center;
    }

    /* class for styling elements horizontally right aligned */
    .right {
        display: block;
        text-align: right;
        margin-left: 0;
        margin-right: auto;
        justify-content: right;
    }

    /* -------------------------------------------------- */
    /* section elements */
    /* -------------------------------------------------- */

    /* horizontal divider line */
    hr {
        border: none;
        height: 1px;
        background: #bdbdbd;
    }

    /* paragraphs, horizontal dividers, figures, tables, code */
    p,
    hr,
    figure,
    table,
    pre {
        /* treat all as "paragraphs", with consistent vertical margins */
        margin-top: 20px;
        margin-bottom: 20px;
    }

    /* -------------------------------------------------- */
    /* figures */
    /* -------------------------------------------------- */

    /* figure */
    figure {
        max-width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    /* figure caption */
    figcaption {
        padding: 0;
        padding-top: 10px;
    }

    /* figure image element */
    figure img {
        max-width: 100%;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }

    /* figure auto-number */
    img + figcaption > span:first-of-type {
        font-weight: bold;
        margin-right: 5px;
    }

    /* -------------------------------------------------- */
    /* tables */
    /* -------------------------------------------------- */

    /* table */
    table {
        border-collapse: collapse;
        border-spacing: 0;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    /* table cells */
    th,
    td {
        border: solid 1px #bdbdbd;
        padding: 10px;
        /* squash table if too wide for page by forcing line breaks */
        overflow-wrap: break-word;
    }

    /* header row and even rows */
    th,
    tr:nth-child(2n) {
        background-color: #fafafa;
    }

    /* odd rows */
    tr:nth-child(2n + 1) {
        background-color: #ffffff;
    }

    /* table caption */
    caption {
        text-align: left;
        padding: 0;
        padding-bottom: 10px;
    }

    /* table auto-number */
    table > caption > span:first-of-type,
    div.table_wrapper > table > caption > span:first-of-type {
        font-weight: bold;
        margin-right: 5px;
    }

    /* -------------------------------------------------- */
    /* code */
    /* -------------------------------------------------- */

    /* multi-line code block */
    pre {
        padding: 10px;
        background-color: #eeeeee;
        color: #000000;
        border-radius: 5px;
        break-inside: avoid;
        text-align: left;
    }

    /* inline code, ie code within normal text */
    :not(pre) > code {
        padding: 0 4px;
        background-color: #eeeeee;
        color: #000000;
        border-radius: 5px;
    }

    /* code text */
    /* apply all children, to reach syntax highlighting sub-elements */
    code,
    code * {
        /* force monospace font */
        font-family: "Source Code Pro", "Courier New", monospace;
    }

    /* -------------------------------------------------- */
    /* quotes */
    /* -------------------------------------------------- */

    /* quoted text */
    blockquote {
        margin: 0;
        padding: 0;
        border-left: 4px solid #bdbdbd;
        padding-left: 16px;
        break-inside: avoid;
    }

    /* -------------------------------------------------- */
    /* banners */
    /* -------------------------------------------------- */

    /* info banners */
    .banner {
        box-sizing: border-box;
        display: block;
        position: relative;
        width: 100%;
        margin-top: 20px;
        margin-bottom: 20px;
        padding: 20px;
        text-align: center;
    }

    /* paragraph in banner */
    .banner > p {
        margin: 0;
    }

    /* -------------------------------------------------- */
    /* highlight colors */
    /* -------------------------------------------------- */

    .white {
        background: #ffffff;
    }
    .lightgrey {
        background: #eeeeee;
    }
    .grey {
        background: #757575;
    }
    .darkgrey {
        background: #424242;
    }
    .black {
        background: #000000;
    }
    .lightred {
        background: #ffcdd2;
    }
    .lightyellow {
        background: #ffecb3;
    }
    .lightgreen {
        background: #dcedc8;
    }
    .lightblue {
        background: #e3f2fd;
    }
    .lightpurple {
        background: #f3e5f5;
    }
    .red {
        background: #f44336;
    }
    .orange {
        background: #ff9800;
    }
    .yellow {
        background: #ffeb3b;
    }
    .green {
        background: #4caf50;
    }
    .blue {
        background: #2196f3;
    }
    .purple {
        background: #9c27b0;
    }
    .white,
    .lightgrey,
    .lightred,
    .lightyellow,
    .lightgreen,
    .lightblue,
    .lightpurple,
    .orange,
    .yellow,
    .white a,
    .lightgrey a,
    .lightred a,
    .lightyellow a,
    .lightgreen a,
    .lightblue a,
    .lightpurple a,
    .orange a,
    .yellow a {
        color: #000000;
    }
    .grey,
    .darkgrey,
    .black,
    .red,
    .green,
    .blue,
    .purple,
    .grey a,
    .darkgrey a,
    .black a,
    .red a,
    .green a,
    .blue a,
    .purple a {
        color: #ffffff;
    }

    /* -------------------------------------------------- */
    /* buttons */
    /* -------------------------------------------------- */

    /* class for styling links like buttons */
    .button {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        margin: 5px;
        padding: 10px 20px;
        font-size: 0.75em;
        font-weight: 600;
        text-transform: uppercase;
        text-decoration: none;
        letter-spacing: 1px;
        background: none;
        color: #2196f3;
        border: solid 1px #bdbdbd;
        border-radius: 5px;
    }

    /* buttons when hovered */
    .button:hover:not([disabled]),
    .icon_button:hover:not([disabled]) {
        cursor: pointer;
        background: #f5f5f5;
    }

    /* buttons when disabled */
    .button[disabled],
    .icon_button[disabled] {
        opacity: 0.35;
        pointer-events: none;
    }

    /* class for styling buttons containg only single icon */
    .icon_button {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        text-decoration: none;
        margin: 0;
        padding: 0;
        background: none;
        border-radius: 5px;
        border: none;
        width: 20px;
        height: 20px;
        min-width: 20px;
        min-height: 20px;
    }

    /* icon button inner svg image */
    .icon_button > svg {
        height: 16px;
    }

    /* -------------------------------------------------- */
    /* icons */
    /* -------------------------------------------------- */

    /* class for styling icons inline with text */
    .inline_icon {
        height: 1em;
        position: relative;
        top: 0.125em;
    }

    /* -------------------------------------------------- */
    /* print control */
    /* -------------------------------------------------- */

    @media print {
        @page {
            /* suggested printing margin */
            margin: 0.5in;
        }

        /* document and "page" elements */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        /* "page" element */
        body {
            font-size: 12pt !important;
            line-height: 2;
        }

        /* all headings */
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            margin: 15px 0;
        }

        /* heading 1 */
        h1 {
            font-size: 1.75em;
        }

        /* heading 2 */
        h2 {
            font-size: 1.5em;
            margin-top: 0;
        }

        /* heading 3 */
        h3 {
            font-size: 1.10em;
        }

        /* figures and tables */
        figure, table {
            font-size: 0.85em;
        }

        /* table cells */
        th,
        td {
            padding: 5px;
        }

        /* shrink font awesome icons */
        i.fas,
        i.fab,
        i.far,
        i.fal {
            transform: scale(0.85);
        }

        /* decrease banner margins */
        .banner {
            margin-top: 15px;
            margin-bottom: 15px;
            padding: 15px;
        }

        /* class for centering an element vertically on its own page */
        .page_center {
            margin: auto;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            vertical-align: middle;
            break-before: page;
            break-after: page;
        }

        /* always insert a page break before the element */
        .page_break_before {
            break-before: page;
        }

        /* always insert a page break after the element */
        .page_break_after {
            break-after: page;
        }

        /* avoid page break before the element */
        .page_break_before_avoid {
            break-before: avoid;
        }

        /* avoid page break after the element */
        .page_break_after_avoid {
            break-after: avoid;
        }

        /* avoid page break inside the element */
        .page_break_inside_avoid {
            break-inside: avoid;
        }
    }

    /* -------------------------------------------------- */
    /* override pandoc css quirks */
    /* -------------------------------------------------- */

    .sourceCode {
        /* prevent unsightly overflow in wide code blocks */
        overflow: auto !important;
    }

    div.sourceCode {
        /* prevent background fill on top-most code block  container */
        background: none !important;
    }

    .sourceCode * {
        /* force consistent line spacing */
        line-height: 1.5 !important;
    }

    div.sourceCode {
        /* style code block margins same as <pre> element */
        margin-top: 20px;
        margin-bottom: 20px;
    }

    /* -------------------------------------------------- */
    /* mathjax */
    /* -------------------------------------------------- */

    /* mathjax containers */
    .math.display > span:not(.MathJax_Preview) {
        /* turn inline element (no dimensions) into block (allows fixed width and thus scrolling) */
        display: flex !important;
        overflow-x: auto !important;
        overflow-y: hidden !important;
        justify-content: center;
        align-items: center;
        margin: 0 !important;
    }

    /* right click menu */
    .MathJax_Menu {
        border-radius: 5px !important;
        border: solid 1px #bdbdbd !important;
        box-shadow: none !important;
    }

    /* equation auto-number */
    span[id^="eq:"] > span.math.display + span {
        font-weight: 600;
    }

    /* equation */
    span[id^="eq:"] > span.math.display > span {
        /* nudge to make room for equation auto-number */
        margin-right: 40px !important;
    }

    /* -------------------------------------------------- */
    /* table scroll plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* table wrapper */
        .table_wrapper {
            /* show scrollbar on tables if necessary to prevent overflow */
            overflow: auto;
            width: 100%;
            margin: 20px 0;
        }

        /* table within table wrapper */
        .table_wrapper table,
        .table_wrapper table * {
            /* don't break table words */
            word-break: normal !important;
        }

        .table_wrapper > table {
            /* move margins from table to table_wrapper to allow margin collapsing */
            margin: 0;
        }
    }

    /* -------------------------------------------------- */
    /* anchors plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* anchor button */
        .anchor {
            opacity: 0;
            margin-left: 5px;
        }

        /* anchor buttons within <h2>'s */
        h2 .anchor {
            margin-left: 10px;
        }

        /* anchor buttons when hovered/focused and anything containing an anchor button when hovered */
        *:hover > .anchor,
        .anchor:hover,
        .anchor:focus {
            opacity: 1;
        }

        /* anchor button when hovered */
        .anchor:hover {
            cursor: pointer;
        }
    }

    /* always show anchor button on devices with no mouse/hover ability */
    @media (hover: none) {
        .anchor {
            opacity: 1;
        }
    }

    /* always hide anchor button on print */
    @media only print {
        .anchor {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* accordion plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* accordion arrow button */
        .accordion_arrow {
            margin-right: 10px;
        }

        /* arrow icon when <h2> data-collapsed attribute true */
        h2[data-collapsed="true"] > .accordion_arrow > svg {
            transform: rotate(-90deg);
        }

        /* all elements (except <h2>'s) when data-collapsed attribute true */
        *:not(h2)[data-collapsed="true"] {
            display: none;
        }

        /* accordion arrow button when hovered and <h2>'s when hovered */
        .accordion_arrow:hover,
        h2[data-collapsed="true"]:hover,
        h2[data-collapsed="false"]:hover {
            cursor: pointer;
        }
    }

    /* always hide accordion arrow button on print */
    @media only print {
        .accordion_arrow {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* tooltips plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* tooltip container */
        #tooltip {
            position: absolute;
            width: 50%;
            min-width: 240px;
            max-width: 75%;
            z-index: 1;
        }

        /* tooltip content */
        #tooltip_content {
            margin-bottom: 5px;
            padding: 20px;
            border-radius: 5px;
            border: solid 1px #bdbdbd;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            background: #ffffff;
            overflow-wrap: break-word;
        }

        /* tooltip copy of paragraphs and figures */
        #tooltip_content > p,
        #tooltip_content > figure {
            margin: 0;
            max-height: 320px;
            overflow-y: auto;
        }

        /* tooltip copy of <img> */
        #tooltip_content > figure > img {
            max-height: 260px;
        }

        /* navigation bar */
        #tooltip_nav_bar {
            margin-top: 10px;
            text-align: center;
        }

        /* navigation bar previous/next buton */
        #tooltip_nav_bar > .icon_button {
            position: relative;
            top: 3px;
        }

        /* navigation bar previous button */
        #tooltip_nav_bar > .icon_button:first-of-type {
            margin-right: 5px;
        }

        /* navigation bar next button */
        #tooltip_nav_bar > .icon_button:last-of-type {
            margin-left: 5px;
        }
    }

    /* always hide tooltip on print */
    @media only print {
        #tooltip {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* jump to first plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* jump button */
        .jump_arrow {
            position: relative;
            top: 0.125em;
            margin-right: 5px;
        }
    }

    /* always hide jump button on print */
    @media only print {
        .jump_arrow {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* link highlight plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* anything with data-highlighted attribute true */
        [data-highlighted="true"] {
            background: #ffeb3b;
        }

        /* anything with data-selected attribute true */
        [data-selected="true"] {
            background: #ff8a65 !important;
        }

        /* animation definition for glow */
        @keyframes highlight_glow {
            0% {
                background: none;
            }
            10% {
                background: #bbdefb;
            }
            100% {
                background: none;
            }
        }

        /* anything with data-glow attribute true */
        [data-glow="true"] {
            animation: highlight_glow 2s;
        }
    }

    /* -------------------------------------------------- */
    /* table of contents plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* toc panel */
        #toc_panel {
            box-sizing: border-box;
            position: fixed;
            top: 0;
            left: 0;
            background: #ffffff;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            z-index: 2;
        }

        /* toc panel when closed */
        #toc_panel[data-open="false"] {
            min-width: 60px;
            width: 60px;
            height: 60px;
            border-right: solid 1px #bdbdbd;
            border-bottom: solid 1px #bdbdbd;
        }

        /* toc panel when open */
        #toc_panel[data-open="true"] {
            min-width: 260px;
            max-width: 480px;
            /* keep panel edge consistent distance away from "page" edge */
            width: calc(((100vw - 8.5in) / 2) - 30px - 40px);
            bottom: 0;
            border-right: solid 1px #bdbdbd;
        }

        /* toc panel header */
        #toc_header {
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            align-items: center;
            height: 60px;
            margin: 0;
            padding: 20px;
        }

        /* toc panel header when hovered */
        #toc_header:hover {
            cursor: pointer;
        }

        /* toc panel header when panel open */
        #toc_panel[data-open="true"] > #toc_header {
            border-bottom: solid 1px #bdbdbd;
        }

        /* toc open/close header button */
        #toc_button {
            margin-right: 20px;
        }

        /* hide toc list and header text when closed */
        #toc_panel[data-open="false"] > #toc_header > *:not(#toc_button),
        #toc_panel[data-open="false"] > #toc_list {
            display: none;
        }

        /* toc list of entries */
        #toc_list {
            box-sizing: border-box;
            width: 100%;
            padding: 20px;
            position: absolute;
            top: calc(60px + 1px);
            bottom: 0;
            overflow: auto;
        }

        /* toc entry, link to section in document */
        .toc_link {
            display: block;
            padding: 5px;
            position: relative;
            font-weight: 600;
            text-decoration: none;
        }

        /* toc entry when hovered or when "viewed" */
        .toc_link:hover,
        .toc_link[data-viewing="true"] {
            background: #f5f5f5;
        }

        /* toc entry, level 1 indentation */
        .toc_link[data-level="1"] {
            margin-left: 0;
        }

        /* toc entry, level 2 indentation */
        .toc_link[data-level="2"] {
            margin-left: 20px;
        }

        /* toc entry, level 3 indentation */
        .toc_link[data-level="3"] {
            margin-left: 40px;
        }

        /* toc entry, level 4 indentation */
        .toc_link[data-level="4"] {
            margin-left: 60px;
        }

        /* toc entry bullets */
        #toc_panel[data-bullets="true"] .toc_link[data-level]:before {
            position: absolute;
            left: -15px;
            top: -1px;
            font-size: 1.5em;
        }

        /* toc entry, level 2 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="2"]:before {
            content: "\2022";
        }

        /* toc entry, level 3 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="3"]:before {
            content: "\25AB";
        }

        /* toc entry, level 4 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="4"]:before {
            content: "-";
        }
    }

    /* when on screen < 8.5in wide */
    @media only screen and (max-width: 8.5in) {
        /* push <body> ("page") element down to make room for toc icon */
        .toc_body_nudge {
            padding-top: 60px;
        }

        /* toc icon when panel closed and not hovered */
        #toc_panel[data-open="false"]:not(:hover) {
            background: rgba(255, 255, 255, 0.75);
        }
    }

    /* always hide toc panel on print */
    @media only print {
        #toc_panel {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* lightbox plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* regular <img> in document when hovered */
        .lightbox_document_img:hover {
            cursor: pointer;
        }

        .body_no_scroll {
            overflow: hidden !important;
        }

        /* screen overlay */
        #lightbox_overlay {
            display: flex;
            flex-direction: column;
            position: fixed;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 3;
        }

        /* middle area containing lightbox image */
        #lightbox_image_container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            padding: 20px;
        }

        /* bottom area containing caption */
        #lightbox_bottom_container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            min-height: 100px;
            max-height: 100px;
            background: rgba(0, 0, 0, 0.5);
        }

        /* image number info text box */
        #lightbox_number_info {
            position: absolute;
            color: #ffffff;
            font-weight: 600;
            left: 2px;
            top: 0;
            z-index: 4;
        }

        /* zoom info text box */
        #lightbox_zoom_info {
            position: absolute;
            color: #ffffff;
            font-weight: 600;
            right: 2px;
            top: 0;
            z-index: 4;
        }

        /* copy of image caption */
        #lightbox_caption {
            box-sizing: border-box;
            display: inline-block;
            width: 100%;
            max-height: 100%;
            padding: 10px 0;
            text-align: center;
            overflow-y: auto;
            color: #ffffff;
        }

        /* navigation previous/next button */
        .lightbox_button {
            width: 100px;
            height: 100%;
            min-width: 100px;
            min-height: 100%;
            color: #ffffff;
        }

        /* navigation previous/next button when hovered */
        .lightbox_button:hover {
            background: none !important;
        }

        /* navigation button icon */
        .lightbox_button > svg {
            height: 25px;
        }

        /* figure auto-number */
        #lightbox_caption > span:first-of-type {
            font-weight: bold;
            margin-right: 5px;
        }

        /* lightbox image when hovered */
        #lightbox_img:hover {
            cursor: grab;
        }

        /* lightbox image when grabbed */
        #lightbox_img:active {
            cursor: grabbing;
        }
    }

    /* when on screen < 480px wide */
    @media only screen and (max-width: 480px) {
        /* make navigation buttons skinnier on small screens to make more room for caption text */
        .lightbox_button {
            width: 50px;
            min-width: 50px;
        }
    }

    /* always hide lightbox on print */
    @media only print {
        #lightbox_overlay {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* hypothesis (annotations) plugin */
    /* -------------------------------------------------- */

    /* side panel */
    .annotator-frame {
        width: 280px !important;
        z-index: 0 !important;
    }

    /* match highlight color to rest of theme */
    .annotator-highlights-always-on .annotator-hl {
        background-color: #ffeb3b !important;
    }

    /* match focused color to rest of theme */
    .annotator-hl.annotator-hl-focused {
        background-color: #ff8a65 !important;
    }

    /* match bucket bar color to rest of theme */
    .annotator-bucket-bar {
        background: #f5f5f5 !important;
    }

    /* always hide toolbar and tooltip on print */
    @media only print {
        .annotator-frame {
            display: none !important;
        }

        hypothesis-adder {
            display: none !important;
        }
    }
</style>
<!-- table scroll plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows tables that are too wide to fit within
        // the page to have a scrollbar instead of being squashed to fit.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tableScroll';

        // default plugin options
        const options = {
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // wrap each table in a container
            const tables = document.querySelectorAll('table');
            for (const table of tables)
                wrapElement(table).classList.add('table_wrapper');
            // table_wrapper CSS class in theme file provides scroll
            // functionality
        }

        // wrap element in div and return div
        function wrapElement(element) {
            const parent = element.parentNode;
            const wrapper = document.createElement('div');
            parent.replaceChild(wrapper, element);
            wrapper.appendChild(element);
            return wrapper;
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- anchors plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin adds an anchor next to each of a certain type
        // of element that provides a human-readable url to that specific
        // item/position in the document (eg "manuscript.html#abstract"). It
        // also makes it such that scrolling out of view of a target removes
        // its identifier from the url.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'anchors';

        // default plugin options
        const options = {
            // which types of elements to add anchors next to, in
            // "document.querySelector" format
            typesQuery: 'h1, h2, h3, figure, table',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // add anchor to each element of specified types
            const elements = document.querySelectorAll(options.typesQuery);
            for (const element of elements)
                addAnchor(element);

            // attach scroll listener to window
            window.addEventListener('scroll', onScroll);
        }

        // when window is scrolled
        function onScroll() {
            // if url has hash and user has scrolled out of view of hash
            // target, remove hash from url
            const target = getHashTarget();
            if (target) {
                if (
                    target.getBoundingClientRect().top > window.innerHeight ||
                    target.getBoundingClientRect().bottom < 0
                )
                    history.pushState(null, null, ' ');
            }
        }

        // add anchor to element
        function addAnchor(element) {
            let withId; // element with unique id
            let addTo; // element to add anchor button to

            // if figure or table, modify withId and addTo to get expected
            // elements
            if (element.tagName.toLowerCase() === 'figure') {
                withId = element.querySelector('img');
                addTo = element.querySelector('figcaption');
            } else if (element.tagName.toLowerCase() === 'table') {
                withId =
                    element.previousElementSibling ||
                    element.parentNode.previousElementSibling;
                addTo = element.querySelector('caption');
            }

            withId = withId || element;
            addTo = addTo || element;
            const id = withId.id || withId.name || null;

            // do not add anchor if element doesn't have assigned id.
            // id is generated by pandoc and is assumed to be unique and
            // human-readable
            if (!id)
                return;

            // create anchor button
            const anchor = document.createElement('a');
            anchor.innerHTML = document.querySelector('.icon_link').innerHTML;
            anchor.title = 'Link to this part of the document';
            anchor.classList.add('icon_button', 'anchor');
            anchor.dataset.ignore = 'true';
            anchor.href = '#' + id;
            addTo.appendChild(anchor);
        }

        // get element that is target of link or url hash
        function getHashTarget() {
            const hash = window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector(
                '[id="' + id + '"], [name="' + id + '"]'
            );
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (hash.indexOf('#fig:') === 0)
                target = target.parentNode;
            if (hash.indexOf('#tbl:') === 0)
                target = target.nextElementSibling;

            return target;
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- link icon -->

<template class="icon_link">
    <!-- modified from: https://fontawesome.com/icons/link -->
    <svg width="16" height="16" viewBox="0 0 512 512">
        <path
            fill="currentColor"
            d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"
        ></path>
    </svg>
</template>
<!-- accordion plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows sections of content under <h2> headings
        // to be collapsible.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'accordion';

        // default plugin options
        const options = {
            // whether to always start expanded ('false'), always start
            // collapsed ('true'), or start collapsed when screen small ('auto')
            startCollapsed: 'auto',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // run through each <h2> heading
            const headings = document.querySelectorAll('h2');
            for (const heading of headings) {
                addArrow(heading);

                // start expanded/collapsed based on option
                if (
                    options.startCollapsed === 'true' ||
                    (options.startCollapsed === 'auto' && isSmallScreen())
                )
                    collapseHeading(heading);
                else
                    expandHeading(heading);
            }

            // attach hash change listener to window
            window.addEventListener('hashchange', onHashChange);
        }

        // when hash (eg manuscript.html#introduction) changes
        function onHashChange() {
            const target = getHashTarget();
            if (target)
                goToElement(target);
        }

        // add arrow to heading
        function addArrow(heading) {
            // add arrow button
            const arrow = document.createElement('button');
            arrow.innerHTML = document.querySelector(
                '.icon_angle_down'
            ).innerHTML;
            arrow.classList.add('icon_button', 'accordion_arrow');
            heading.insertBefore(arrow, heading.firstChild);

            // attach click listener to heading and button
            heading.addEventListener('click', onHeadingClick);
            arrow.addEventListener('click', onArrowClick);
        }

        // determine if on mobile-like device with small screen
        function isSmallScreen() {
            return Math.min(window.innerWidth, window.innerHeight) < 480;
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // get element that is target of hash
        function getHashTarget(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector(
                '[id="' + id + '"], [name="' + id + '"]'
            );
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (hash.indexOf('#fig:') === 0)
                target = target.parentNode;
            if (hash.indexOf('#tbl:') === 0)
                target = target.nextElementSibling;

            return target;
        }

        // when <h2> heading is clicked
        function onHeadingClick(event) {
            // only collapse if <h2> itself is target of click (eg, user did
            // not click on anchor within <h2>)
            if (event.target === this)
                toggleCollapse(this);
        }

        // when arrow button is clicked
        function onArrowClick() {
            toggleCollapse(this.parentNode);
        }

        // collapse section if expanded, expand if collapsed
        function toggleCollapse(heading) {
            if (heading.dataset.collapsed === 'false')
                collapseHeading(heading);
            else
                expandHeading(heading);
        }

        // elements to exclude from collapse, such as table of contents panel,
        // hypothesis panel, etc
        const exclude = '#toc_panel, div.annotator-frame, #lightbox_overlay';

        // collapse section
        function collapseHeading(heading) {
            heading.setAttribute('data-collapsed', 'true');
            const children = getChildren(heading);
            for (const child of children)
                child.setAttribute('data-collapsed', 'true');
        }

        // expand section
        function expandHeading(heading) {
            heading.setAttribute('data-collapsed', 'false');
            const children = getChildren(heading);
            for (const child of children)
                child.setAttribute('data-collapsed', 'false');
        }

        // get list of elements between this <h2> and next <h2> or <h1>
        // ("children" of the <h2> section)
        function getChildren(heading) {
            return nextUntil(heading, 'h2, h1', exclude);
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get list of elements after a start element up to element matching
        // query
        function nextUntil(element, query, exclude) {
            const elements = [];
            while (element = element.nextElementSibling, element) {
                if (element.matches(query))
                    break;
                if (!element.matches(exclude))
                    elements.push(element);
            }
            return elements;
        }

        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- angle down icon -->

<template class="icon_angle_down">
    <!-- modified from: https://fontawesome.com/icons/angle-down -->
    <svg width="16" height="16" viewBox="0 0 448 512">
        <path
            fill="currentColor"
            d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"
        ></path>
    </svg>
</template>
<!-- tooltips plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when the user hovers or
        // focuses a link to a citation or figure, a tooltip appears with a
        // preview of the reference content, along with arrows to navigate
        // between instances of the same reference in the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tooltips';

        // default plugin options
        const options = {
            // whether user must click off to close tooltip instead of just
            // un-hovering
            clickClose: 'false',
            // delay (in ms) between opening and closing tooltip
            delay: '100',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            const links = getLinks();
            for (const link of links) {
                // attach hover and focus listeners to link
                link.addEventListener('mouseover', onLinkHover);
                link.addEventListener('mouseleave', onLinkUnhover);
                link.addEventListener('focus', onLinkFocus);
                link.addEventListener('touchend', onLinkTouch);
            }

            // attach mouse, key, and resize listeners to window
            window.addEventListener('mousedown', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onResize);
        }

        // when link is hovered
        function onLinkHover() {
            // function to open tooltip
            const delayOpenTooltip = function() {
                openTooltip(this);
            }.bind(this);

            // run open function after delay
            this.openTooltipTimer = window.setTimeout(
                delayOpenTooltip,
                options.delay
            );
        }

        // when mouse leaves link
        function onLinkUnhover() {
            // cancel opening tooltip
            window.clearTimeout(this.openTooltipTimer);

            // don't close on unhover if option specifies
            if (options.clickClose === 'true')
                return;

            // function to close tooltip
            const delayCloseTooltip = function() {
                // if tooltip open and if mouse isn't over tooltip, close
                const tooltip = document.getElementById('tooltip');
                if (tooltip && !tooltip.matches(':hover'))
                    closeTooltip();
            };

            // run close function after delay
            this.closeTooltipTimer = window.setTimeout(
                delayCloseTooltip,
                options.delay
            );
        }

        // when link is focused (tabbed to)
        function onLinkFocus(event) {
            openTooltip(this);
        }

        // when link is touched on touch screen
        function onLinkTouch(event) {
            // attempt to force hover state on first tap always, and trigger
            // regular link click (and navigation) on second tap
            if (event.target === document.activeElement)
                event.target.click();
            else {
                document.activeElement.blur();
                event.target.focus();
            }
            if (event.cancelable)
                event.preventDefault();
            event.stopPropagation();
            return false;
        }

        // when mouse is clicked anywhere in window
        function onClick(event) {
            closeTooltip();
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            switch (event.key) {
                // trigger click of prev button
                case 'ArrowLeft':
                    const prevButton = document.getElementById(
                        'tooltip_prev_button'
                    );
                    if (prevButton)
                        prevButton.click();
                    break;
                // trigger click of next button
                case 'ArrowRight':
                    const nextButton = document.getElementById(
                        'tooltip_next_button'
                    );
                    if (nextButton)
                        nextButton.click();
                    break;
                // close on esc
                case 'Escape':
                    closeTooltip();
                    break;
            }
        }

        // when window is resized or zoomed
        function onResize() {
            closeTooltip();
        }

        // get all links of types we wish to handle
        function getLinks() {
            const queries = [];
            // exclude buttons, anchor links, toc links, etc
            const exclude =
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            queries.push('a[href^="#ref-"]' + exclude); // citation links
            queries.push('a[href^="#fig:"]' + exclude); // figure links
            const query = queries.join(', ');
            return document.querySelectorAll(query);
        }

        // get links with same target, get index of link in set, get total
        // same links
        function getSameLinks(link) {
            const sameLinks = [];
            const links = getLinks();
            for (const otherLink of links) {
                if (
                    otherLink.getAttribute('href') === link.getAttribute('href')
                )
                    sameLinks.push(otherLink);
            }

            return {
                elements: sameLinks,
                index: sameLinks.indexOf(link),
                total: sameLinks.length
            };
        }

        // open tooltip
        function openTooltip(link) {
            // delete tooltip if it exists, start fresh
            closeTooltip();

            // make tooltip element
            const tooltip = makeTooltip(link);

            // if source couldn't be found and tooltip not made, exit
            if (!tooltip)
                return;

            // make navbar elements
            const navBar = makeNavBar(link);
            if (navBar)
                tooltip.firstElementChild.appendChild(navBar);

            // attach tooltip to page
            document.body.appendChild(tooltip);

            // position tooltip
            const position = function() {
                positionTooltip(link);
            };
            position();

            // if tooltip contains images, position again after they've loaded
            const imgs = tooltip.querySelectorAll('img');
            for (const img of imgs)
                img.addEventListener('load', position);
        }

        // close (delete) tooltip
        function closeTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip)
                tooltip.remove();
        }

        // make tooltip
        function makeTooltip(link) {
            // get target element that link points to
            const source = getSource(link);

            // if source can't be found, exit
            if (!source)
                return;

            // create new tooltip
            const tooltip = document.createElement('div');
            tooltip.id = 'tooltip';
            const tooltipContent = document.createElement('div');
            tooltipContent.id = 'tooltip_content';
            tooltip.appendChild(tooltipContent);

            // make copy of source node and put in tooltip
            const sourceCopy = makeCopy(source);
            tooltipContent.appendChild(sourceCopy);

            // attach mouse event listeners
            tooltip.addEventListener('click', onTooltipClick);
            tooltip.addEventListener('mousedown', onTooltipClick);
            tooltip.addEventListener('touchstart', onTooltipClick);
            tooltip.addEventListener('mouseleave', onTooltipUnhover);

            // (for interaction with lightbox plugin)
            // transfer click on tooltip copied img to original img
            const sourceImg = source.querySelector('img');
            const sourceCopyImg = sourceCopy.querySelector('img');
            if (sourceImg && sourceCopyImg) {
                const clickImg = function() {
                    sourceImg.click();
                    closeTooltip();
                };
                sourceCopyImg.addEventListener('click', clickImg);
            }

            return tooltip;
        }

        // make carbon copy of html dom element
        function makeCopy(source) {
            const sourceCopy = source.cloneNode(true);

            // delete elements marked with ignore (eg anchor and jump buttons)
            const deleteFromCopy = sourceCopy.querySelectorAll(
                '[data-ignore="true"]'
            );
            for (const element of deleteFromCopy)
                element.remove();

            // delete certain element attributes
            const attributes = [
                'id',
                'data-collapsed',
                'data-selected',
                'data-highlighted',
                'data-glow'
            ];
            for (const attribute of attributes) {
                sourceCopy.removeAttribute(attribute);
                const elements = sourceCopy.querySelectorAll(
                    '[' + attribute + ']'
                );
                for (const element of elements)
                    element.removeAttribute(attribute);
            }

            return sourceCopy;
        }

        // when tooltip is clicked
        function onTooltipClick(event) {
            // when user clicks on tooltip, stop click from transferring
            // outside of tooltip (eg, click off to close tooltip, or eg click
            // off to unhighlight same refs)
            event.stopPropagation();
        }

        // when tooltip is unhovered
        function onTooltipUnhover(event) {
            if (options.clickClose === 'true')
                return;

            // make sure new mouse/touch/focus no longer over tooltip or any
            // element within it
            const tooltip = document.getElementById('tooltip');
            if (!tooltip)
                return;
            if (this.contains(event.relatedTarget))
                return;

            closeTooltip();
        }

        // make nav bar to go betwen prev/next instances of same reference
        function makeNavBar(link) {
            // find other links to the same source
            const sameLinks = getSameLinks(link);

            // don't show nav bar when singular reference
            if (sameLinks.total <= 1)
                return;

            // find prev/next links with same target
            const prevLink = getPrevLink(link, sameLinks);
            const nextLink = getNextLink(link, sameLinks);

            // create nav bar
            const navBar = document.createElement('div');
            navBar.id = 'tooltip_nav_bar';
            const text = sameLinks.index + 1 + ' of ' + sameLinks.total;

            // create nav bar prev/next buttons
            const prevButton = document.createElement('button');
            const nextButton = document.createElement('button');
            prevButton.id = 'tooltip_prev_button';
            nextButton.id = 'tooltip_next_button';
            prevButton.title =
                'Jump to the previous occurence of this item in the document [←]';
            nextButton.title =
                'Jump to the next occurence of this item in the document [→]';
            prevButton.classList.add('icon_button');
            nextButton.classList.add('icon_button');
            prevButton.innerHTML = document.querySelector(
                '.icon_caret_left'
            ).innerHTML;
            nextButton.innerHTML = document.querySelector(
                '.icon_caret_right'
            ).innerHTML;
            navBar.appendChild(prevButton);
            navBar.appendChild(document.createTextNode(text));
            navBar.appendChild(nextButton);

            // attach click listeners to buttons
            prevButton.addEventListener('click', function() {
                onPrevNextClick(link, prevLink);
            });
            nextButton.addEventListener('click', function() {
                onPrevNextClick(link, nextLink);
            });

            return navBar;
        }

        // get previous link with same target
        function getPrevLink(link, sameLinks) {
            if (!sameLinks)
                sameLinks = getSameLinks(link);
            // wrap index to other side if < 1
            let index;
            if (sameLinks.index - 1 >= 0)
                index = sameLinks.index - 1;
            else
                index = sameLinks.total - 1;
            return sameLinks.elements[index];
        }

        // get next link with same target
        function getNextLink(link, sameLinks) {
            if (!sameLinks)
                sameLinks = getSameLinks(link);
            // wrap index to other side if > total
            let index;
            if (sameLinks.index + 1 <= sameLinks.total - 1)
                index = sameLinks.index + 1;
            else
                index = 0;
            return sameLinks.elements[index];
        }

        // get element that is target of link or url hash
        function getSource(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector(
                '[id="' + id + '"], [name="' + id + '"]'
            );
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (hash.indexOf('#ref-') === 0)
                target = target.querySelector('p');
            else if (hash.indexOf('#fig:') === 0)
                target = target.parentNode;
            else if (hash.indexOf('#tbl:') === 0)
                return;

            return target;
        }

        // when prev/next arrow button is clicked
        function onPrevNextClick(link, prevNextLink) {
            if (link && prevNextLink)
                goToElement(prevNextLink, window.innerHeight * 0.5);
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // determine position to place tooltip based on link position in
        // viewport and tooltip size
        function positionTooltip(link, left, top) {
            const tooltipElement = document.getElementById('tooltip');
            if (!tooltipElement)
                return;

            // get convenient vars for position/dimensions of
            // link/tooltip/page/view
            link = getRectInPage(link);
            const tooltip = getRectInPage(tooltipElement);
            const view = getRectInPage();

            // horizontal positioning
            if (left)
                // use explicit value
                left = left;
            else if (link.left + tooltip.width < view.right)
                // fit tooltip to right of link
                left = link.left;
            else if (link.right - tooltip.width > view.left)
                // fit tooltip to left of link
                left = link.right - tooltip.width;
            // center tooltip in view
            else
                left = (view.right - view.left) / 2 - tooltip.width / 2;

            // vertical positioning
            if (top)
                // use explicit value
                top = top;
            else if (link.top - tooltip.height > view.top)
                // fit tooltip above link
                top = link.top - tooltip.height;
            else if (link.bottom + tooltip.height < view.bottom)
                // fit tooltip below link
                top = link.bottom;
            else {
                // center tooltip in view
                top = view.top + view.height / 2 - tooltip.height / 2;
                // nudge off of link to left/right if possible
                if (link.right + tooltip.width < view.right)
                    left = link.right;
                else if (link.left - tooltip.width > view.left)
                    left = link.left - tooltip.width;
            }

            tooltipElement.style.left = left + 'px';
            tooltipElement.style.top = top + 'px';
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get position of element relative to page
        function getRectInPage(element) {
            const rect = getRectInView(element);
            const body = getRectInView(document.body);

            const newRect = {};
            newRect.left = rect.left - body.left;
            newRect.top = rect.top - body.top;
            newRect.right = rect.right - body.left;
            newRect.bottom = rect.bottom - body.top;
            newRect.width = rect.width;
            newRect.height = rect.height;

            return newRect;
        }

        // (for interaction with accordion plugin)
        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // (for interaction with accordion plugin)
        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // (for interaction with accordion plugin)
        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- caret left icon -->

<template class="icon_caret_left">
    <!-- modified from: https://fontawesome.com/icons/caret-left -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M192 127.338v257.324c0 17.818-21.543 26.741-34.142 14.142L29.196 270.142c-7.81-7.81-7.81-20.474 0-28.284l128.662-128.662c12.599-12.6 34.142-3.676 34.142 14.142z"
        ></path>
    </svg>
</template>

<!-- caret right icon -->

<template class="icon_caret_right">
    <!-- modified from: https://fontawesome.com/icons/caret-right -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"
        ></path>
    </svg>
</template>
<!-- jump to first plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin adds a button next to each reference entry,
        // figure, and table that jumps the page to the first occurrence of a
        // link to that item in the manuscript.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'jumpToFirst';

        // default plugin options
        const options = {
            // whether to add buttons next to reference entries
            references: 'true',
            // whether to add buttons next to figures
            figures: 'true',
            // whether to add buttons next to tables
            tables: 'true',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            if (options.references !== 'false')
                makeReferenceButtons();
            if (options.figures !== 'false')
                makeFigureButtons();
            if (options.tables !== 'false')
                makeTableButtons();
        }

        // when jump button clicked
        function onButtonClick() {
            const first = getFirstOccurrence(this.dataset.id);
            if (!first)
                return;

            // update url hash so navigating "back" in history will return
            // user to jump button
            window.location.hash = this.dataset.id;
            // scroll to link
            window.setTimeout(function() {
                goToElement(first, window.innerHeight * 0.5);
            }, 0);
        }

        // get first occurence of link to item in document
        function getFirstOccurrence(id) {
            let query = 'a';
            query += '[href="#' + id + '"]';
            // exclude buttons, anchor links, toc links, etc
            query +=
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            return document.querySelector(query);
        }

        // add button next to each reference entry
        function makeReferenceButtons() {
            const references = document.querySelectorAll('div[id^="ref-"]');
            for (const reference of references) {
                // get reference id and element to add button to
                const id = reference.id;
                const container = reference.firstElementChild;
                const first = getFirstOccurrence(id);

                // if can't find link to reference, ignore
                if (!first)
                    continue;

                // make jump button
                let button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this reference in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.innerHTML = button.outerHTML + container.innerHTML;
                button = container.firstElementChild;
                button.addEventListener('click', onButtonClick);
            }
        }

        // add button next to each figure
        function makeFigureButtons() {
            const figures = document.querySelectorAll('img[id^="fig:"]');
            for (const figure of figures) {
                // get figure id and element to add button to
                const id = figure.id;
                const container = figure.nextElementSibling;
                const first = getFirstOccurrence(id);

                // if can't find link to figure, ignore
                if (!first)
                    continue;

                // make jump button
                const button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this figure in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.insertBefore(button, container.firstElementChild);
                button.addEventListener('click', onButtonClick);
            }
        }

        // add button next to each figure
        function makeTableButtons() {
            const tables = document.querySelectorAll('a[name^="tbl:"]');
            for (const table of tables) {
                // get ref id and element to add button to
                const id = table.name;
                const container = table.nextElementSibling.querySelector(
                    'caption'
                );
                const first = getFirstOccurrence(id);

                // if can't find link to table, ignore
                if (!first)
                    continue;

                // make jump button
                const button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this table in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.insertBefore(button, container.firstElementChild);
                button.addEventListener('click', onButtonClick);
            }
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // (for interaction with accordion plugin)
        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- angle double up icon -->

<template class="icon_angle_double_up">
    <!-- modified from: https://fontawesome.com/icons/angle-double-up -->
    <svg width="16" height="16" viewBox="0 0 320 512">
        <path
            fill="currentColor"
            d="M177 255.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 351.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 425.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1zm-34-192L7 199.7c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l96.4-96.4 96.4 96.4c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9l-136-136c-9.2-9.4-24.4-9.4-33.8 0z"
        ></path>
    </svg>
</template>
<!-- link highlight plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when a user hovers or
        // focuses a link, other links that have the same target will be
        // highlighted. It also makes it such that when clicking a link, the
        // target of the link (eg reference, figure, table) is briefly
        // highlighted.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'linkHighlight';

        // default plugin options
        const options = {
            // whether to also highlight links that go to external urls
            externalLinks: 'false',
            // whether user must click off to unhighlight instead of just
            // un-hovering
            clickUnhighlight: 'false',
            // whether to also highlight links that are unique
            highlightUnique: 'true',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            const links = getLinks();
            for (const link of links) {
                // attach mouse and focus listeners to link
                link.addEventListener('mouseenter', onLinkFocus);
                link.addEventListener('focus', onLinkFocus);
                link.addEventListener('mouseleave', onLinkUnhover);
            }

            // attach click and hash change listeners to window
            window.addEventListener('click', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('hashchange', onHashChange);

            // run hash change on window load in case user has navigated
            // directly to hash
            onHashChange();
        }

        // when link is focused (tabbed to) or hovered
        function onLinkFocus() {
            highlight(this);
        }

        // when link is unhovered
        function onLinkUnhover() {
            if (options.clickUnhighlight !== 'true')
                unhighlightAll();
        }

        // when the mouse is clicked anywhere in window
        function onClick(event) {
            unhighlightAll();
        }

        // when hash (eg manuscript.html#introduction) changes
        function onHashChange() {
            const target = getHashTarget();
            if (target)
                glowElement(target);
        }

        // get element that is target of link or url hash
        function getHashTarget(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector(
                '[id="' + id + '"], [name="' + id + '"]'
            );
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (hash.indexOf('#fig:') === 0)
                target = target.parentNode;
            else if (hash.indexOf('#tbl:') === 0)
                target = target.nextElementSibling.querySelector('caption');

            return target;
        }

        // start glow sequence on an element
        function glowElement(element) {
            const startGlow = function() {
                onGlowEnd();
                element.dataset.glow = 'true';
                element.addEventListener('animationend', onGlowEnd);
            };
            const onGlowEnd = function() {
                element.removeAttribute('data-glow');
                element.removeEventListener('animationend', onGlowEnd);
            };
            startGlow();
        }

        // highlight link and all others with same target
        function highlight(link) {
            // force unhighlight all to start fresh
            unhighlightAll();

            // get links with same target
            if (!link)
                return;
            const sameLinks = getSameLinks(link);

            // if link unique and option is off, exit and don't highlight
            if (sameLinks.length <= 1 && options.highlightUnique !== 'true')
                return;

            // highlight all same links, and "select" (special highlight) this
            // one
            for (const sameLink of sameLinks) {
                if (sameLink === link)
                    sameLink.setAttribute('data-selected', 'true');
                else
                    sameLink.setAttribute('data-highlighted', 'true');
            }
        }

        // unhighlight all links
        function unhighlightAll() {
            const links = getLinks();
            for (const link of links) {
                link.setAttribute('data-selected', 'false');
                link.setAttribute('data-highlighted', 'false');
            }
        }

        // get links with same target
        function getSameLinks(link) {
            const results = [];
            const links = getLinks();
            for (const otherLink of links) {
                if (
                    otherLink.getAttribute('href') === link.getAttribute('href')
                )
                    results.push(otherLink);
            }
            return results;
        }

        // get all links of types we wish to handle
        function getLinks() {
            let query = 'a';
            if (options.externalLinks !== 'true')
                query += '[href^="#"]';
            // exclude buttons, anchor links, toc links, etc
            query +=
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            return document.querySelectorAll(query);
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- table of contents plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin provides a "table of contents" (toc) panel on
        // the side of the document that allows the user to conveniently
        // navigate between sections of the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tableOfContents';

        // default plugin options
        const options = {
            // which types of elements to add links for, in
            // "document.querySelector" format
            typesQuery: 'h1, h2, h3',
            // whether default behavior is to be closed ('false'), open
            // ('true'), or only open when screen wide enough to fit panel
            // ('auto'). note: still always starts closed when page loads.
            open: 'auto',
            // if list item is more than this many characters, text will be
            // truncated
            charLimit: '50',
            // whether or not to show bullets next to each toc item
            bullets: 'false',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // make toc panel and populate with entries (links to document
            // sections)
            const panel = makePanel();
            if (!panel)
                return;
            makeEntries(panel);
            document.body.insertBefore(panel, document.body.firstChild);

            closePanel();

            // attach click, scroll, and hash change listeners to window
            window.addEventListener('click', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('scroll', onScroll);
            window.addEventListener('hashchange', onScroll);
            window.addEventListener('keyup', onKeyUp);
            onScroll();

            // add class to push document body down out of way of toc button
            document.body.classList.add('toc_body_nudge');
        }

        // determine if screen wide enough to fit toc panel
        function isSmallScreen() {
            // in default theme:
            // 816px = 8.5in = width of "page" (<body>) element
            // 260px = min width of toc panel (*2 for both sides of <body>)
            return window.innerWidth < 816 + 260 * 2;
        }

        // open/close panel based on option and screen size
        function openOrClosePanel() {
            if (
                options.open === 'true' ||
                (options.open === 'auto' && !isSmallScreen())
            )
                openPanel();
            else
                closePanel();
        }

        // when mouse is clicked anywhere in window
        function onClick() {
            const panel = document.getElementById('toc_panel');
            if (!panel)
                return;

            if (panel.dataset.open === 'true')
                openOrClosePanel();
        }

        // when window is scrolled or hash changed
        function onScroll() {
            highlightViewed();
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            // close on esc
            if (event.key === 'Escape')
                closePanel();
        }

        // find entry of currently viewed document section in toc and highlight
        function highlightViewed() {
            const firstId = getFirstInView(options.typesQuery);

            // get toc entries (links), unhighlight all, then highlight viewed
            const list = document.getElementById('toc_list');
            if (!firstId || !list)
                return;
            const links = list.querySelectorAll('a');
            for (const link of links)
                link.dataset.viewing = 'false';
            const link = list.querySelector('a[href="#' + firstId + '"]');
            if (!link)
                return;
            link.dataset.viewing = 'true';
        }

        // get first or previous toc listed element in top half of view
        function getFirstInView(query) {
            // get all elements matching query and with id
            const elements = document.querySelectorAll(query);
            const elementsWithIds = [];
            for (const element of elements) {
                if (element.id)
                    elementsWithIds.push(element);
            }


            // get first or previous element in top half of view
            for (let i = 0; i < elementsWithIds.length; i++) {
                const element = elementsWithIds[i];
                const prevElement = elementsWithIds[Math.max(0, i - 1)];
                if (element.getBoundingClientRect().top >= 0) {
                    if (
                        element.getBoundingClientRect().top <
                        window.innerHeight / 2
                    )
                        return element.id;
                    else
                        return prevElement.id;
                }
            }
        }

        // make panel
        function makePanel() {
            // create panel
            const panel = document.createElement('div');
            panel.id = 'toc_panel';
            if (options.bullets === 'true')
                panel.dataset.bullets = 'true';

            // create header
            const header = document.createElement('div');
            header.id = 'toc_header';

            // create toc button
            const button = document.createElement('button');
            button.id = 'toc_button';
            button.innerHTML = document.querySelector(
                '.icon_th_list'
            ).innerHTML;
            button.classList.add('icon_button');

            // create header text
            const text = document.createElement('h3');
            text.innerHTML = 'Table of Contents';

            // create container for toc list
            const list = document.createElement('div');
            list.id = 'toc_list';

            // attach click listeners
            panel.addEventListener('click', onPanelClick);
            header.addEventListener('click', onHeaderClick);
            button.addEventListener('click', onButtonClick);

            // attach elements
            header.appendChild(button);
            header.appendChild(text);
            panel.appendChild(header);
            panel.appendChild(list);

            return panel;
        }

        // create toc entries (links) to each element of the specified types
        function makeEntries(panel) {
            const elements = document.querySelectorAll(options.typesQuery);
            for (const element of elements) {
                // do not add link if element doesn't have assigned id
                if (!element.id)
                    continue;

                // create link/list item
                const link = document.createElement('a');
                link.classList.add('toc_link');
                switch (element.tagName.toLowerCase()) {
                    case 'h1':
                        link.dataset.level = '1';
                        break;
                    case 'h2':
                        link.dataset.level = '2';
                        break;
                    case 'h3':
                        link.dataset.level = '3';
                        break;
                    case 'h4':
                        link.dataset.level = '4';
                        break;
                }
                link.title = element.innerText;
                let text = element.innerText;
                if (text.length > options.charLimit)
                    text = text.slice(0, options.charLimit) + '...';
                link.innerHTML = text;
                link.href = '#' + element.id;
                link.addEventListener('click', onLinkClick);

                // attach link
                panel.querySelector('#toc_list').appendChild(link);
            }
        }

        // when panel is clicked
        function onPanelClick(event) {
            // stop click from propagating to window/document and closing panel
            event.stopPropagation();
        }

        // when header itself is clicked
        function onHeaderClick(event) {
            togglePanel();
        }

        // when button is clicked
        function onButtonClick(event) {
            togglePanel();
            // stop header underneath button from also being clicked
            event.stopPropagation();
        }

        // when link is clicked
        function onLinkClick() {
            openOrClosePanel();
        }

        // open panel if closed, close if opened
        function togglePanel() {
            const panel = document.getElementById('toc_panel');
            if (!panel)
                return;

            if (panel.dataset.open === 'true')
                closePanel();
            else
                openPanel();
        }

        // open panel
        function openPanel() {
            const panel = document.getElementById('toc_panel');
            if (panel)
                panel.dataset.open = 'true';
        }

        // close panel
        function closePanel() {
            const panel = document.getElementById('toc_panel');
            if (panel)
                panel.dataset.open = 'false';
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- th list icon -->

<template class="icon_th_list">
    <!-- modified from: https://fontawesome.com/icons/th-list -->
    <svg width="16" height="16" viewBox="0 0 512 512" tabindex="-1">
        <path
            fill="currentColor"
            d="M96 96c0 26.51-21.49 48-48 48S0 122.51 0 96s21.49-48 48-48 48 21.49 48 48zM48 208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm0 160c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm96-236h352c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h352c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h352c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
            tabindex="-1"
        ></path>
    </svg>
</template>
<!-- lightbox plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when a user clicks on an
        // image, the image fills the screen and the user can pan/drag/zoom
        // the image and navigate between other images in the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'lightbox';

        // default plugin options
        const options = {
            // list of possible zoom/scale factors
            zoomSteps:
                '0.1, 0.25, 0.333333, 0.5, 0.666666, 0.75, 1,' +
                '1.25, 1.5, 1.75, 2, 2.5, 3, 3.5, 4, 5, 6, 7, 8',
            // whether to fit image to view ('fit'), display at 100% and shrink
            // if necessary ('shrink'), or always display at 100% ('100')
            defaultZoom: 'fit',
            // whether to zoom in/out toward center of view ('true') or mouse
            // ('false')
            centerZoom: 'false',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // run through each <img> element
            const imgs = document.querySelectorAll('figure > img');
            let count = 1;
            for (const img of imgs) {
                img.classList.add('lightbox_document_img');
                img.dataset.number = count;
                img.dataset.total = imgs.length;
                img.addEventListener('click', openLightbox);
                count++;
            }

            // attach mouse and key listeners to window
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('keyup', onKeyUp);
        }

        // when mouse is moved anywhere in window
        function onWindowMouseMove(event) {
            window.mouseX = event.clientX;
            window.mouseY = event.clientY;
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            switch (event.key) {
                // trigger click of prev button
                case 'ArrowLeft':
                    const prevButton = document.getElementById(
                        'lightbox_prev_button'
                    );
                    if (prevButton)
                        prevButton.click();
                    break;
                // trigger click of next button
                case 'ArrowRight':
                    const nextButton = document.getElementById(
                        'lightbox_next_button'
                    );
                    if (nextButton)
                        nextButton.click();
                    break;
                // close on esc
                case 'Escape':
                    closeLightbox();
                    break;
            }
        }

        // open lightbox
        function openLightbox() {
            const lightbox = makeLightbox(this);
            if (!lightbox)
                return;

            blurBody(lightbox);
            document.body.appendChild(lightbox);
        }

        // make lightbox
        function makeLightbox(img) {
            // delete lightbox if it exists, start fresh
            closeLightbox();

            // create screen overlay containing lightbox
            const overlay = document.createElement('div');
            overlay.id = 'lightbox_overlay';

            // create image info boxes
            const numberInfo = document.createElement('div');
            const zoomInfo = document.createElement('div');
            numberInfo.id = 'lightbox_number_info';
            zoomInfo.id = 'lightbox_zoom_info';

            // create container for image
            const imageContainer = document.createElement('div');
            imageContainer.id = 'lightbox_image_container';
            const lightboxImg = makeLightboxImg(
                img,
                imageContainer,
                numberInfo,
                zoomInfo
            );
            imageContainer.appendChild(lightboxImg);

            // create bottom container for caption and navigation buttons
            const bottomContainer = document.createElement('div');
            bottomContainer.id = 'lightbox_bottom_container';
            const caption = makeCaption(img);
            const prevButton = makePrevButton(img);
            const nextButton = makeNextButton(img);
            bottomContainer.appendChild(prevButton);
            bottomContainer.appendChild(caption);
            bottomContainer.appendChild(nextButton);

            // attach top middle and bottom to overlay
            overlay.appendChild(numberInfo);
            overlay.appendChild(zoomInfo);
            overlay.appendChild(imageContainer);
            overlay.appendChild(bottomContainer);

            return overlay;
        }

        // make <img> object that is intuitively draggable and zoomable
        function makeLightboxImg(
            sourceImg,
            container,
            numberInfoBox,
            zoomInfoBox
        ) {
            // create copy of source <img>
            const img = sourceImg.cloneNode(true);
            img.classList.remove('lightbox_document_img');
            img.removeAttribute('id');
            img.removeAttribute('width');
            img.removeAttribute('height');
            img.style.position = 'unset';
            img.style.margin = '0';
            img.style.padding = '0';
            img.style.width = '';
            img.style.height = '';
            img.style.minWidth = '';
            img.style.minHeight = '';
            img.style.maxWidth = '';
            img.style.maxHeight = '';
            img.id = 'lightbox_img';

            // build sorted list of unique zoomSteps, always including a 100%
            let zoomSteps = [];
            const optionsZooms = options.zoomSteps.split(/[^0-9.]/);
            for (const optionZoom of optionsZooms) {
                const newZoom = parseFloat(optionZoom);
                if (newZoom && !zoomSteps.includes(newZoom))
                    zoomSteps.push(newZoom);
            }
            if (!zoomSteps.includes(1))
                zoomSteps.push(1);
            zoomSteps = zoomSteps.sort(function sortNumber(a, b) {
                return a - b;
            });

            // <img> object property variables
            let zoom = 1;
            let translateX = 0;
            let translateY = 0;
            let clickMouseX = undefined;
            let clickMouseY = undefined;
            let clickTranslateX = undefined;
            let clickTranslateY = undefined;

            updateNumberInfo();

            // update image numbers displayed in info box
            function updateNumberInfo() {
                numberInfoBox.innerHTML =
                    sourceImg.dataset.number + ' of ' + sourceImg.dataset.total;
            }

            // update zoom displayed in info box
            function updateZoomInfo() {
                let zoomInfo = zoom * 100;
                if (!Number.isInteger(zoomInfo))
                    zoomInfo = zoomInfo.toFixed(2);
                zoomInfoBox.innerHTML = zoomInfo + '%';
            }

            // move to closest zoom step above current zoom
            const zoomIn = function() {
                for (const zoomStep of zoomSteps) {
                    if (zoomStep > zoom) {
                        zoom = zoomStep;
                        break;
                    }
                }
                updateTransform();
            };

            // move to closest zoom step above current zoom
            const zoomOut = function() {
                zoomSteps.reverse();
                for (const zoomStep of zoomSteps) {
                    if (zoomStep < zoom) {
                        zoom = zoomStep;
                        break;
                    }
                }
                zoomSteps.reverse();

                updateTransform();
            };

            // update display of <img> based on scale/translate properties
            const updateTransform = function() {
                // set transform
                img.style.transform =
                    'translate(' +
                    (translateX || 0) +
                    'px,' +
                    (translateY || 0) +
                    'px) scale(' +
                    (zoom || 1) +
                    ')';

                // get new width/height after scale
                const rect = img.getBoundingClientRect();
                // limit translate
                translateX = Math.max(translateX, -rect.width / 2);
                translateX = Math.min(translateX, rect.width / 2);
                translateY = Math.max(translateY, -rect.height / 2);
                translateY = Math.min(translateY, rect.height / 2);

                // set transform
                img.style.transform =
                    'translate(' +
                    (translateX || 0) +
                    'px,' +
                    (translateY || 0) +
                    'px) scale(' +
                    (zoom || 1) +
                    ')';

                updateZoomInfo();
            };

            // fit <img> to container
            const fit = function() {
                // no x/y offset, 100% zoom by default
                translateX = 0;
                translateY = 0;
                zoom = 1;

                // widths of <img> and container
                const imgWidth = img.naturalWidth;
                const imgHeight = img.naturalHeight;
                const containerWidth = parseFloat(
                    window.getComputedStyle(container).width
                );
                const containerHeight = parseFloat(
                    window.getComputedStyle(container).height
                );

                // how much zooming is needed to fit <img> to container
                const xRatio = imgWidth / containerWidth;
                const yRatio = imgHeight / containerHeight;
                const maxRatio = Math.max(xRatio, yRatio);
                const newZoom = 1 / maxRatio;

                // fit <img> to container according to option
                if (options.defaultZoom === 'shrink') {
                    if (maxRatio > 1)
                        zoom = newZoom;
                } else if (options.defaultZoom === 'fit')
                    zoom = newZoom;

                updateTransform();
            };

            // when mouse wheel is rolled anywhere in container
            const onContainerWheel = function(event) {
                if (!event)
                    return;

                // let ctrl + mouse wheel to zoom behave as normal
                if (event.ctrlKey)
                    return;

                // prevent normal scroll behavior
                event.preventDefault();
                event.stopPropagation();

                // point around which to scale img
                const viewRect = container.getBoundingClientRect();
                const viewX = (viewRect.left + viewRect.right) / 2;
                const viewY = (viewRect.top + viewRect.bottom) / 2;
                const originX = options.centerZoom === 'true' ? viewX : mouseX;
                const originY = options.centerZoom === 'true' ? viewY : mouseY;

                // get point on image under origin
                const oldRect = img.getBoundingClientRect();
                const oldPercentX = (originX - oldRect.left) / oldRect.width;
                const oldPercentY = (originY - oldRect.top) / oldRect.height;

                // increment/decrement zoom
                if (event.deltaY < 0)
                    zoomIn();
                if (event.deltaY > 0)
                    zoomOut();

                // get offset between previous image point and origin
                const newRect = img.getBoundingClientRect();
                const offsetX =
                    originX - (newRect.left + newRect.width * oldPercentX);
                const offsetY =
                    originY - (newRect.top + newRect.height * oldPercentY);

                // translate image to keep image point under origin
                translateX += offsetX;
                translateY += offsetY;

                // perform translate
                updateTransform();
            };

            // when container is clicked
            function onContainerClick(event) {
                // if container itself is target of click, and not other
                // element above it
                if (event.target === this)
                    closeLightbox();
            }

            // when mouse button is pressed on image
            const onImageMouseDown = function(event) {
                // store original mouse position relative to image
                clickMouseX = window.mouseX;
                clickMouseY = window.mouseY;
                clickTranslateX = translateX;
                clickTranslateY = translateY;
                event.stopPropagation();
                event.preventDefault();
            };

            // when mouse button is released anywhere in window
            const onWindowMouseUp = function(event) {
                // reset original mouse position
                clickMouseX = undefined;
                clickMouseY = undefined;
                clickTranslateX = undefined;
                clickTranslateY = undefined;

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('mouseup', onWindowMouseUp);
            };

            // when mouse is moved anywhere in window
            const onWindowMouseMove = function(event) {
                if (
                    clickMouseX === undefined ||
                    clickMouseY === undefined ||
                    clickTranslateX === undefined ||
                    clickTranslateY === undefined
                )
                    return;

                // offset image based on original and current mouse position
                translateX = clickTranslateX + window.mouseX - clickMouseX;
                translateY = clickTranslateY + window.mouseY - clickMouseY;
                updateTransform();
                event.preventDefault();

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('mousemove', onWindowMouseMove);
            };

            // when window is resized
            const onWindowResize = function(event) {
                fit();

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('resize', onWindowResize);
            };

            // attach the necessary event listeners
            img.addEventListener('dblclick', fit);
            img.addEventListener('mousedown', onImageMouseDown);
            container.addEventListener('wheel', onContainerWheel);
            container.addEventListener('mousedown', onContainerClick);
            container.addEventListener('touchstart', onContainerClick);
            window.addEventListener('mouseup', onWindowMouseUp);
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('resize', onWindowResize);

            // run fit() after lightbox atttached to document and <img> Loaded
            // so needed container and img dimensions available
            img.addEventListener('load', fit);

            return img;
        }

        // make caption
        function makeCaption(img) {
            const caption = document.createElement('div');
            caption.id = 'lightbox_caption';
            const captionSource = img.nextElementSibling;
            if (captionSource.tagName.toLowerCase() === 'figcaption') {
                const captionCopy = makeCopy(captionSource);
                caption.innerHTML = captionCopy.innerHTML;
            }

            caption.addEventListener('touchstart', function(event) {
                event.stopPropagation();
            });

            return caption;
        }

        // make carbon copy of html dom element
        function makeCopy(source) {
            const sourceCopy = source.cloneNode(true);

            // delete elements marked with ignore (eg anchor and jump buttons)
            const deleteFromCopy = sourceCopy.querySelectorAll(
                '[data-ignore="true"]'
            );
            for (const element of deleteFromCopy)
                element.remove();

            // delete certain element attributes
            const attributes = [
                'id',
                'data-collapsed',
                'data-selected',
                'data-highlighted',
                'data-glow'
            ];
            for (const attribute of attributes) {
                sourceCopy.removeAttribute(attribute);
                const elements = sourceCopy.querySelectorAll(
                    '[' + attribute + ']'
                );
                for (const element of elements)
                    element.removeAttribute(attribute);
            }

            return sourceCopy;
        }

        // make button to jump to previous image in document
        function makePrevButton(img) {
            const prevButton = document.createElement('button');
            prevButton.id = 'lightbox_prev_button';
            prevButton.title = 'Jump to the previous image in the document [←]';
            prevButton.classList.add('icon_button', 'lightbox_button');
            prevButton.innerHTML = document.querySelector(
                '.icon_caret_left'
            ).innerHTML;

            // attach click listeners to button
            prevButton.addEventListener('click', function() {
                getPrevImg(img).click();
            });

            return prevButton;
        }

        // make button to jump to next image in document
        function makeNextButton(img) {
            const nextButton = document.createElement('button');
            nextButton.id = 'lightbox_next_button';
            nextButton.title = 'Jump to the next image in the document [→]';
            nextButton.classList.add('icon_button', 'lightbox_button');
            nextButton.innerHTML = document.querySelector(
                '.icon_caret_right'
            ).innerHTML;

            // attach click listeners to button
            nextButton.addEventListener('click', function() {
                getNextImg(img).click();
            });

            return nextButton;
        }

        // get previous image in document
        function getPrevImg(img) {
            const imgs = document.querySelectorAll('.lightbox_document_img');

            // find index of provided img
            let index;
            for (index = 0; index < imgs.length; index++) {
                if (imgs[index] === img)
                    break;
            }


            // wrap index to other side if < 1
            if (index - 1 >= 0)
                index--;
            else
                index = imgs.length - 1;
            return imgs[index];
        }

        // get next image in document
        function getNextImg(img) {
            const imgs = document.querySelectorAll('.lightbox_document_img');

            // find index of provided img
            let index;
            for (index = 0; index < imgs.length; index++) {
                if (imgs[index] === img)
                    break;
            }


            // wrap index to other side if > total
            if (index + 1 <= imgs.length - 1)
                index++;
            else
                index = 0;
            return imgs[index];
        }

        // close lightbox
        function closeLightbox() {
            focusBody();

            const lightbox = document.getElementById('lightbox_overlay');
            if (lightbox)
                lightbox.remove();
        }

        // make all elements behind lightbox non-focusable
        function blurBody(overlay) {
            const all = document.querySelectorAll('*');
            for (const element of all)
                element.tabIndex = -1;
            document.body.classList.add('body_no_scroll');
        }

        // make all elements focusable again
        function focusBody() {
            const all = document.querySelectorAll('*');
            for (const element of all)
                element.removeAttribute('tabIndex');
            document.body.classList.remove('body_no_scroll');
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- caret left icon -->

<template class="icon_caret_left">
    <!-- modified from: https://fontawesome.com/icons/caret-left -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M192 127.338v257.324c0 17.818-21.543 26.741-34.142 14.142L29.196 270.142c-7.81-7.81-7.81-20.474 0-28.284l128.662-128.662c12.599-12.6 34.142-3.676 34.142 14.142z"
        ></path>
    </svg>
</template>

<!-- caret right icon -->

<template class="icon_caret_right">
    <!-- modified from: https://fontawesome.com/icons/caret-right -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"
        ></path>
    </svg>
</template>
<!-- attributes plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows arbitrary HTML attributes to be attached
        // to (almost) any element. Place an HTML comment inside or next to the
        // desired element in the format <!-- $attribute="value" -->

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'attributes';

        // default plugin options
        const options = {
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // get list of comments in document
            const comments = findComments();

            for(const comment of comments)
                if (comment.parentElement)
                    addAttributes(
                        comment.parentElement,
                        comment.nodeValue.trim()
                    );
        }

        // add html attributes to specified element based on string of 
        // html attributes and values
        function addAttributes(element, text) {
            // regex's for finding attribute/value pairs in the format of
            // attribute="value" or attribute='value
            const regex2 = /\$([a-zA-Z\-]+)?=\"(.+?)\"/;
            const regex1 = /\$([a-zA-Z\-]+)?=\'(.+?)\'/;

            // loop through attribute/value pairs
            let match;
            while(match = text.match(regex2) || text.match(regex1)) {
                // get attribute and value from regex capture groups
                let attribute = match[1];
                let value = match[2];

                // remove from string
                text = text.substring(match.index + match[0].length);

                if (!attribute || !value)
                    break;

                // set attribute of parent element
                try {
                    element.setAttribute(attribute, value);
                } catch(error) {
                    console.log(error);
                }

                // special case for colspan
                if (attribute === 'colspan')
                    removeTableCells(element, value);
            }
        }

        // get list of comment elements in document
        function findComments() {
            const comments = [];

            // iterate over comment nodes in document
            function acceptNode(node) {
                return NodeFilter.FILTER_ACCEPT;
            }
            const iterator = document.createNodeIterator(
                document.body,
                NodeFilter.SHOW_COMMENT,
                acceptNode
            );
            let node;
            while(node = iterator.nextNode())
                comments.push(node);

            return comments;
        }

        // remove certain number of cells after specified cell
        function removeTableCells(cell, number) {
            number = parseInt(number);
            if (!number)
                return;

            // remove elements
            for(; number > 1; number--) {
                if (cell.nextElementSibling)
                    cell.nextElementSibling.remove();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- math plugin configuration -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        "CommonHTML": { linebreaks: { automatic: true } },
        "HTML-CSS": { linebreaks: { automatic: true } },
        "SVG": { linebreaks: { automatic: true } },
        "fast-preview": { disabled: true }
    });
</script>

<!-- math plugin -->

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'>
    // /////////////////////////
    // DESCRIPTION
    // /////////////////////////

    // This third-party plugin 'MathJax' allows the proper rendering of
    // math/equations written in LaTeX.

    // https://www.mathjax.org/
</script>
<!-- annotations plugin configuration -->

<script>
    window.hypothesisConfig = function() {
        return {
            branding: {
                accentColor: '#2196f3',
                appBackgroundColor: '#f8f8f8',
                ctaBackgroundColor: '#f8f8f8',
                ctaTextColor: '#000000',
                selectionFontFamily: 'Open Sans, Helvetica, sans serif',
                annotationFontFamily: 'Open Sans, Helvetica, sans serif'
            }
        };
    };
</script>

<!-- annotations plugin -->

<script src='https://hypothes.is/embed.js'>
    // /////////////////////////
    // DESCRIPTION
    // /////////////////////////

    // This third-party plugin 'Hypothesis' allows public annotation of the
    // manuscript.

    // https://web.hypothes.is/
</script>
<!-- analytics plugin -->

<!-- copy and paste code from Google Analytics or similar service here -->
</body>
</html>
